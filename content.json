{"posts":[{"title":"CUTLASS SM90 Pipeline and mbarrier Deep Dive","text":"This article provides a deep dive into the CUTLASS SM90 Pipeline mechanism and how it maps to the underlying mbarrier PTX instructions. All code references are from the official NVIDIA CUTLASS repository. 1. IntroductionNVIDIA Hopper (SM90) introduces hardware-accelerated asynchronous data movement through TMA (Tensor Memory Accelerator) and a new barrier synchronization mechanism called mbarrier. CUTLASS provides a high-level Pipeline abstraction that leverages these features for efficient producer-consumer synchronization. Key Source Files: sm90_pipeline.hpp - Pipeline implementation barrier.h - Barrier primitives 2. Core Data Structures2.1 PipelineStateThe PipelineState structure tracks the current position in the circular buffer: 123456789101112131415161718192021// Source: include/cutlass/pipeline/sm90_pipeline.hpp:170-250template&lt;uint32_t Stages_&gt;struct PipelineState { static constexpr uint32_t Stages = Stages_; int index_ = 0; // Current stage index (0 to Stages-1) uint32_t phase_ = 0; // Current phase (0 or 1), flips when wrapping uint32_t count_ = 0; // Total iteration count CUTLASS_DEVICE void operator++() { if constexpr (Stages &gt; 0) { ++index_; ++count_; if (index_ == Stages) { index_ = 0; phase_ ^= 1; // Flip phase when wrapping around } } }}; The phase bit is crucial for barrier synchronization - it toggles each time we complete a full cycle through all stages, allowing the barrier to distinguish between different iterations. 2.2 PipelineTmaAsync ClassThis is the main Pipeline class for TMA-based asynchronous loads: 12345678910111213141516171819202122232425262728293031// Source: include/cutlass/pipeline/sm90_pipeline.hpp:270-299template &lt;int Stages_&gt;class PipelineTmaAsync {public: using FullBarrier = cutlass::arch::ClusterTransactionBarrier; using EmptyBarrier = cutlass::arch::ClusterBarrier; using ProducerBarrierType = FullBarrier::ValueType; using ConsumerBarrierType = EmptyBarrier::ValueType; static constexpr uint32_t Stages = Stages_; struct SharedStorage { FullBarrier full_barrier_[Stages]; // Signals &quot;data ready&quot; EmptyBarrier empty_barrier_[Stages]; // Signals &quot;space available&quot; }; enum class ThreadCategory { NonParticipant, Producer, Consumer, ProducerConsumer }; struct Params { uint32_t transaction_bytes = 0; ThreadCategory role = ThreadCategory::NonParticipant; uint32_t is_leader = 0; uint32_t num_consumers = 0; uint32_t num_producers = 1; }; // ...}; Key Design Points: Dual Barrier Architecture: Each pipeline stage has two barriers - FullBarrier (data ready) and EmptyBarrier (space available) ClusterTransactionBarrier: The FullBarrier type supports transaction-based completion (bytes transferred) ClusterBarrier: The EmptyBarrier type uses traditional arrival counting 3. Barrier Types and PTX Instructions3.1 ClusterBarrierThe ClusterBarrier provides cluster-wide arrive-wait synchronization: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// Source: include/cutlass/arch/barrier.h:341-532struct ClusterBarrier { using ValueType = uint64_t;protected: ValueType barrier_; // 64-bit mbarrier object in SMEMpublic: // Initialize barrier with expected arrival count CUTLASS_HOST_DEVICE static void init(ValueType const* smem_ptr, uint32_t arrive_count) { uint32_t smem_addr = cute::cast_smem_ptr_to_uint(smem_ptr); asm volatile( &quot;mbarrier.init.shared::cta.b64 [%1], %0;&quot; : : &quot;r&quot;(arrive_count), &quot;r&quot;(smem_addr)); } // Blocking wait with spin loop CUTLASS_HOST_DEVICE static void wait(ValueType const* smem_ptr, uint32_t phase) { uint32_t smem_addr = cute::cast_smem_ptr_to_uint(smem_ptr); uint32_t ticks = 0x989680; // ~10M cycles timeout before retry asm volatile( &quot;.reg .pred P1;\\n&quot; &quot;LAB_WAIT:\\n&quot; &quot;mbarrier.try_wait.parity.shared::cta.b64 P1, [%0], %1, %2;\\n&quot; &quot;@P1 bra DONE;\\n&quot; &quot;bra LAB_WAIT;\\n&quot; &quot;DONE:&quot; : : &quot;r&quot;(smem_addr), &quot;r&quot;(phase), &quot;r&quot;(ticks)); } // Non-blocking try wait CUTLASS_HOST_DEVICE static bool try_wait(ValueType const* smem_ptr, uint32_t phase) { uint32_t smem_addr = cute::cast_smem_ptr_to_uint(smem_ptr); uint32_t waitComplete; asm volatile( &quot;.reg .pred P1;\\n&quot; &quot;mbarrier.try_wait.parity.shared::cta.b64 P1, [%1], %2;\\n&quot; &quot;selp.b32 %0, 1, 0, P1;&quot; : &quot;=r&quot;(waitComplete) : &quot;r&quot;(smem_addr), &quot;r&quot;(phase)); return static_cast&lt;bool&gt;(waitComplete); } // Local CTA arrive CUTLASS_HOST_DEVICE static void arrive(ValueType const* smem_ptr) { uint32_t smem_addr = cute::cast_smem_ptr_to_uint(smem_ptr); asm volatile( &quot;mbarrier.arrive.shared::cta.b64 _, [%0];&quot; : : &quot;r&quot;(smem_addr)); } // Remote cluster arrive (to another CTA's SMEM) CUTLASS_HOST_DEVICE static void arrive(ValueType const* smem_ptr, uint32_t cta_id, uint32_t pred) { uint32_t smem_addr = cute::cast_smem_ptr_to_uint(smem_ptr); if (pred) { asm volatile( &quot;.reg .b32 remAddr32;\\n&quot; &quot;mapa.shared::cluster.u32 remAddr32, %0, %1;\\n&quot; &quot;mbarrier.arrive.shared::cluster.b64 _, [remAddr32];&quot; : : &quot;r&quot;(smem_addr), &quot;r&quot;(cta_id)); } }}; 3.2 ClusterTransactionBarrierThis extends ClusterBarrier with transaction byte counting, essential for TMA operations: 1234567891011121314151617181920212223242526272829303132333435// Source: include/cutlass/arch/barrier.h:538-693struct ClusterTransactionBarrier : public ClusterBarrier { // Arrive + set expected transaction bytes CUTLASS_HOST_DEVICE static void arrive_and_expect_tx(ValueType const* smem_ptr, uint32_t transaction_bytes) { uint32_t smem_addr = cute::cast_smem_ptr_to_uint(smem_ptr); asm volatile( &quot;mbarrier.arrive.expect_tx.shared::cta.b64 _, [%1], %0;&quot; : : &quot;r&quot;(transaction_bytes), &quot;r&quot;(smem_addr)); } // Set expected bytes without arrive (for additional TMA loads) CUTLASS_HOST_DEVICE static void expect_transaction(ValueType const* smem_ptr, uint32_t transaction_bytes) { uint32_t smem_addr = cute::cast_smem_ptr_to_uint(smem_ptr); asm volatile( &quot;mbarrier.expect_tx.shared::cta.b64 [%1], %0;&quot; : : &quot;r&quot;(transaction_bytes), &quot;r&quot;(smem_addr)); } // Complete transaction (decrement pending bytes) - called by TMA hardware CUTLASS_HOST_DEVICE static void complete_transaction( ValueType const* smem_ptr, uint32_t dst_cta_id, uint32_t transaction_bytes, uint32_t pred = 1) { uint32_t smem_addr = cute::cast_smem_ptr_to_uint(smem_ptr); smem_addr = cute::set_block_rank(smem_addr, dst_cta_id); asm volatile( &quot;.reg .pred p;\\n&quot; &quot;setp.eq.u32 p, %2, 1;\\n&quot; &quot;@p mbarrier.complete_tx.shared::cluster.relaxed.cluster.b64 [%1], %0;&quot; : : &quot;r&quot;(transaction_bytes), &quot;r&quot;(smem_addr), &quot;r&quot;(pred)); }}; 4. Pipeline API to PTX MappingHere’s a complete mapping of Pipeline APIs to their underlying PTX instructions: Pipeline API Barrier Type PTX Instruction producer_acquire (wait) EmptyBarrier mbarrier.try_wait.parity (spin) producer_acquire (leader) FullBarrier mbarrier.arrive.expect_tx producer_commit FullBarrier mbarrier.complete_tx (TMA auto) consumer_try_wait FullBarrier mbarrier.try_wait.parity (once) consumer_wait FullBarrier mbarrier.try_wait.parity (spin) consumer_release EmptyBarrier mbarrier.arrive 5. Producer APIs5.1 producer_acquireWaits for buffer space and sets expected transaction bytes: 1234567891011// Source: include/cutlass/pipeline/sm90_pipeline.hpp:511-528CUTLASS_DEVICEvoid producer_acquire(uint32_t stage, uint32_t phase) { // Step 1: Wait for consumer to release the buffer empty_barrier_ptr_[stage].wait(phase); // Step 2: Leader thread sets expected transaction bytes if (params_.is_leader) { full_barrier_ptr_[stage].arrive_and_expect_tx(params_.transaction_bytes); }} What happens: All producer threads wait on EmptyBarrier until the buffer is available Only the leader thread (one per warp) calls arrive_and_expect_tx to set up the FullBarrier with expected bytes 5.2 producer_get_barrierReturns the barrier pointer for TMA to signal completion: 12345// Source: include/cutlass/pipeline/sm90_pipeline.hpp:456-459CUTLASS_DEVICEProducerBarrierType* producer_get_barrier(PipelineState state) { return reinterpret_cast&lt;ProducerBarrierType*&gt;(&amp;full_barrier_ptr_[state.index()]);} This pointer is passed to TMA operations so the hardware can automatically signal the barrier when data transfer completes. 5.3 producer_tailPrevents premature producer exit in cluster scenarios: 12345678// Source: include/cutlass/pipeline/sm90_pipeline.hpp:447-454CUTLASS_DEVICEvoid producer_tail(PipelineState state) { for (int count = 0; count &lt; Stages; ++count) { empty_barrier_ptr_[state.index()].wait(state.phase()); ++state; }} This ensures all consumers have finished using all pipeline stages before the producer block exits. 6. Consumer APIs6.1 consumer_try_waitNon-blocking check if data is ready: 123456789// Source: include/cutlass/pipeline/sm90_pipeline.hpp:590-597CUTLASS_DEVICEConsumerToken consumer_try_wait(uint32_t stage, uint32_t phase, uint32_t skip_wait) { if (skip_wait) { return {BarrierStatus::WaitDone}; } bool barrier_status = full_barrier_ptr_[stage].try_wait(phase); return {static_cast&lt;BarrierStatus&gt;(barrier_status)};} Returns: BarrierStatus::WaitDone (1): Data is ready BarrierStatus::WaitAgain (0): Data not ready yet 6.2 consumer_waitBlocking wait for data: 12345678// Source: include/cutlass/pipeline/sm90_pipeline.hpp:611-620CUTLASS_DEVICEvoid consumer_wait(uint32_t stage, uint32_t phase, ConsumerToken barrier_token) { if (barrier_token != BarrierStatus::WaitDone) { full_barrier_ptr_[stage].wait(phase); } // If already WaitDone, skip the wait} 6.3 consumer_releaseSignals that the buffer can be reused: 12345// Source: include/cutlass/pipeline/sm90_pipeline.hpp:628-630CUTLASS_DEVICEvoid consumer_release(uint32_t stage, uint32_t skip = false) { empty_barrier_ptr_[stage].arrive(dst_blockid_, is_signaling_thread_ &amp; (!skip));} This decrements the EmptyBarrier arrival count, allowing the producer to reuse the buffer. 7. mbarrier 64-bit StructureThe mbarrier is a 64-bit hardware structure in shared memory: Field Bits Description Phase Bit 1 Toggles on barrier completion Pending TX Count ~20 Expected bytes (for TransactionBarrier) Arrival Count ~20 Remaining arrivals needed Completion Condition: 1Pending TX Count == 0 AND Arrival Count == 0 → Phase Bit flips 8. Complete Workflow Example12345678910111213141516171819202122232425262728293031323334353637383940// Producer Thread (TMA loader)PipelineState producer_state = make_producer_start_state&lt;Pipeline&gt;();for (int k = 0; k &lt; num_tiles; ++k) { // 1. Acquire buffer (wait for space + set expected bytes) pipeline.producer_acquire(producer_state); // 2. Get barrier for TMA auto* barrier = pipeline.producer_get_barrier(producer_state); // 3. Issue TMA load (hardware will auto-complete barrier) copy(tma_load, gmem_tensor, smem_tensor, barrier); ++producer_state;}// 4. Wait for all consumers before exitpipeline.producer_tail(producer_state);// Consumer Thread (MMA compute)PipelineState consumer_state{0, 0, 0};for (int k = 0; k &lt; num_tiles; ++k) { // 1. Try wait (opportunistic) auto token = pipeline.consumer_try_wait(consumer_state); // 2. Do some other work... // 3. Finalize wait if needed pipeline.consumer_wait(consumer_state, token); // 4. Use data in MMA operations gemm(smem_tensor, accumulators); // 5. Release buffer for producer pipeline.consumer_release(consumer_state); ++consumer_state;} 9. Key Takeaways SM90 Specific: This pipeline mechanism is designed for NVIDIA Hopper architecture (SM90+) Hardware Acceleration: TMA automatically signals barriers on completion - no software intervention needed Phase-Based Synchronization: The phase bit enables reuse of barriers across iterations Cluster Support: Barriers can operate across CTAs in a cluster via mapa address remapping Transaction Barriers: ClusterTransactionBarrier tracks byte counts for TMA operations, while ClusterBarrier uses simple arrival counting References CUTLASS GitHub Repository NVIDIA PTX ISA - mbarrier CUDA Programming Guide - Asynchronous Barrier","link":"/2024/12/23/pipeline-barrier-ptx-mapping/"}],"tags":[{"name":"CUTLASS","slug":"CUTLASS","link":"/tags/CUTLASS/"},{"name":"Pipeline","slug":"Pipeline","link":"/tags/Pipeline/"},{"name":"mbarrier","slug":"mbarrier","link":"/tags/mbarrier/"},{"name":"PTX","slug":"PTX","link":"/tags/PTX/"},{"name":"SM90","slug":"SM90","link":"/tags/SM90/"}],"categories":[{"name":"CUTLASS","slug":"CUTLASS","link":"/categories/CUTLASS/"}],"pages":[{"title":"","text":"/* Custom styles for wider page width */ /* ===== Dark Mode Theme Toggle ===== */ /* Theme toggle button in navbar */ .theme-toggle { cursor: pointer; padding: 0.5rem; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; color: inherit; background: transparent; border: none; transition: transform 0.3s ease; } .theme-toggle:hover { transform: scale(1.1); } .theme-toggle .icon-sun, .theme-toggle .icon-moon { display: none; } /* Light mode: show moon icon */ html:not([data-theme=\"dark\"]) .theme-toggle .icon-moon { display: inline; } /* Dark mode: show sun icon */ html[data-theme=\"dark\"] .theme-toggle .icon-sun { display: inline; } /* ===== Dark Mode Styles ===== */ html[data-theme=\"dark\"] { --bg-color: #1a1a2e; --bg-color-secondary: #16213e; --text-color: #e4e4e4; --text-color-secondary: #a0a0a0; --border-color: #2d2d4a; --card-bg: #1f1f38; --link-color: #6c9fff; --link-hover: #99b8ff; --code-bg: #0d1117; } html[data-theme=\"dark\"] body { background-color: var(--bg-color) !important; color: var(--text-color) !important; } html[data-theme=\"dark\"] .navbar { background-color: var(--bg-color-secondary) !important; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); } html[data-theme=\"dark\"] .navbar-item, html[data-theme=\"dark\"] .navbar-link { color: var(--text-color) !important; } html[data-theme=\"dark\"] .navbar-item:hover, html[data-theme=\"dark\"] .navbar-link:hover { background-color: rgba(255, 255, 255, 0.1) !important; color: var(--link-color) !important; } html[data-theme=\"dark\"] .card { background-color: var(--card-bg) !important; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3) !important; } html[data-theme=\"dark\"] .card-content { background-color: var(--card-bg) !important; } html[data-theme=\"dark\"] .title, html[data-theme=\"dark\"] .subtitle, html[data-theme=\"dark\"] h1, html[data-theme=\"dark\"] h2, html[data-theme=\"dark\"] h3, html[data-theme=\"dark\"] h4, html[data-theme=\"dark\"] h5, html[data-theme=\"dark\"] h6 { color: var(--text-color) !important; } html[data-theme=\"dark\"] .content { color: var(--text-color) !important; } html[data-theme=\"dark\"] a { color: var(--link-color) !important; } html[data-theme=\"dark\"] a:hover { color: var(--link-hover) !important; } html[data-theme=\"dark\"] .menu-label { color: var(--text-color-secondary) !important; } html[data-theme=\"dark\"] .menu-list a { color: var(--text-color) !important; } html[data-theme=\"dark\"] .menu-list a:hover { background-color: rgba(255, 255, 255, 0.05) !important; color: var(--link-color) !important; } html[data-theme=\"dark\"] .tag { background-color: var(--border-color) !important; color: var(--text-color) !important; } html[data-theme=\"dark\"] .footer { background-color: var(--bg-color-secondary) !important; color: var(--text-color-secondary) !important; } html[data-theme=\"dark\"] .widget { background-color: var(--card-bg) !important; } html[data-theme=\"dark\"] pre, html[data-theme=\"dark\"] code { background-color: var(--code-bg) !important; } html[data-theme=\"dark\"] .hljs { background-color: var(--code-bg) !important; } html[data-theme=\"dark\"] .article-meta, html[data-theme=\"dark\"] .level-item { color: var(--text-color-secondary) !important; } html[data-theme=\"dark\"] .button.is-primary { background-color: #3273dc !important; } html[data-theme=\"dark\"] .input, html[data-theme=\"dark\"] .textarea, html[data-theme=\"dark\"] .select select { background-color: var(--bg-color-secondary) !important; border-color: var(--border-color) !important; color: var(--text-color) !important; } html[data-theme=\"dark\"] .pagination-link, html[data-theme=\"dark\"] .pagination-previous, html[data-theme=\"dark\"] .pagination-next { background-color: var(--card-bg) !important; border-color: var(--border-color) !important; color: var(--text-color) !important; } html[data-theme=\"dark\"] .toc-list a { color: var(--text-color) !important; } html[data-theme=\"dark\"] .toc-list a:hover, html[data-theme=\"dark\"] .toc-list a.is-active { color: var(--link-color) !important; } html[data-theme=\"dark\"] hr { background-color: var(--border-color) !important; } html[data-theme=\"dark\"] blockquote { background-color: var(--bg-color-secondary) !important; border-left-color: var(--link-color) !important; } html[data-theme=\"dark\"] table th, html[data-theme=\"dark\"] table td { border-color: var(--border-color) !important; } html[data-theme=\"dark\"] table thead th { background-color: var(--bg-color-secondary) !important; color: var(--text-color) !important; } html[data-theme=\"dark\"] table tbody tr:nth-child(even) { background-color: rgba(255, 255, 255, 0.02) !important; } /* ===== End Dark Mode Styles ===== */ /* ===== Hide right sidebar on post pages ===== */ body.is-post-page .column.column-right { display: none !important; } /* When right sidebar is hidden, expand main content */ body.is-post-page .column.column-main.is-8-tablet.is-8-desktop.is-6-widescreen { width: 70% !important; flex: none !important; } body.is-post-page .column.column-left.is-4-tablet.is-4-desktop.is-3-widescreen { width: 30% !important; flex: none !important; } /* For two-column layout on post pages */ body.is-post-page .columns { justify-content: center; } /* ===== End Hide Right Sidebar ===== */ /* Increase container max-width */ html body .container { max-width: 1600px !important; } /* Main content column - wider */ html body .column.is-8-tablet, html body .column.is-8-desktop, html body .column.is-8-widescreen, html body .is-8-desktop, html body .is-8-widescreen { flex: none !important; width: 70% !important; } /* Sidebar column - narrower */ html body .column.is-4-tablet, html body .column.is-4-desktop, html body .column.is-4-widescreen, html body .is-4-desktop, html body .is-4-widescreen { flex: none !important; width: 30% !important; } /* Two sidebar layout - left sidebar smaller */ html body .column.is-8-tablet.is-8-desktop.is-6-widescreen { width: 55% !important; flex: none !important; } html body .column.is-4-tablet.is-4-desktop.is-3-widescreen { width: 22.5% !important; flex: none !important; } /* Card content padding */ html body .card-content { padding: 1.25rem 1.5rem; } /* Code block */ html body .content pre { max-width: 100%; overflow-x: auto; } /* Article content */ html body .article-content { max-width: 100%; } /* Large screens */ @media screen and (min-width: 1408px) { html body .container { max-width: 1700px !important; } } @media screen and (min-width: 1600px) { html body .container { max-width: 1900px !important; } } @media screen and (min-width: 1800px) { html body .container { max-width: 2100px !important; } html body .column.is-8-desktop, html body .column.is-8-widescreen { width: 72% !important; } html body .column.is-4-desktop, html body .column.is-4-widescreen { width: 28% !important; } }","link":"/css/custom.css"},{"title":"","text":"// Theme toggle functionality (function() { 'use strict'; // Detect if current page is a post page and add class to body function detectPostPage() { // Check if URL matches post pattern (e.g., /2024/12/23/post-name/) const path = window.location.pathname; const isPost = /^\\/\\d{4}\\/\\d{2}\\/\\d{2}\\//.test(path); if (isPost) { document.body.classList.add('is-post-page'); } else { document.body.classList.remove('is-post-page'); } } // Get saved theme or default to light function getTheme() { return localStorage.getItem('theme') || 'light'; } // Apply theme to document function applyTheme(theme) { if (theme === 'dark') { document.documentElement.setAttribute('data-theme', 'dark'); } else { document.documentElement.removeAttribute('data-theme'); } } // Save theme preference function saveTheme(theme) { localStorage.setItem('theme', theme); } // Toggle between light and dark function toggleTheme() { const currentTheme = getTheme(); const newTheme = currentTheme === 'dark' ? 'light' : 'dark'; applyTheme(newTheme); saveTheme(newTheme); } // Create and inject toggle button into navbar function createToggleButton() { const navbarEnd = document.querySelector('.navbar-end'); if (!navbarEnd) return; // Check if button already exists if (document.querySelector('.theme-toggle')) return; const toggleBtn = document.createElement('a'); toggleBtn.className = 'navbar-item theme-toggle'; toggleBtn.title = 'Toggle Dark Mode'; toggleBtn.innerHTML = ''; toggleBtn.addEventListener('click', function(e) { e.preventDefault(); toggleTheme(); }); // Insert before the search button const searchBtn = navbarEnd.querySelector('.search'); if (searchBtn) { navbarEnd.insertBefore(toggleBtn, searchBtn); } else { navbarEnd.appendChild(toggleBtn); } } // Initialize on page load function init() { // Apply saved theme immediately applyTheme(getTheme()); // Detect post page and hide right sidebar detectPostPage(); // Create toggle button when DOM is ready if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', createToggleButton); } else { createToggleButton(); } } // Apply theme immediately to prevent flash applyTheme(getTheme()); // Run init when DOM is ready if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); } else { init(); } // Re-create button and detect page type after pjax navigation (Icarus uses pjax) document.addEventListener('pjax:complete', function() { createToggleButton(); detectPostPage(); }); })();","link":"/js/theme-toggle.js"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"关于","text":"关于本站这是一个专注于 NVIDIA CUTLASS 和 CuTE 内部实现的学习笔记站点。 内容涵盖 Pipeline 同步机制: mbarrier、双 Barrier 架构、PTX 指令映射 Epilogue 融合: EVT (Expression Visitor Tree)、FusionCallbacks CuTE Tensor: Layout、Stride、TMA 联系方式 GitHub: DrXuQian","link":"/about/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}]}