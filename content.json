{"posts":[{"title":"CUTLASS SM90 Pipeline 与 mbarrier 深度解析","text":"本文深入解析 CUTLASS SM90 Pipeline 机制及其底层 mbarrier PTX 指令的映射关系。所有代码引用均来自 NVIDIA CUTLASS 官方仓库。 1. mbarrier 原理1.1 什么是 mbarriermbarrier（Memory Barrier）是 NVIDIA Hopper (SM90) 架构引入的硬件同步原语，存储在共享内存（SMEM）中。它是一个 64-bit 的硬件对象，支持： 到达计数（Arrival Counting）：追踪有多少线程已经到达 barrier 事务计数（Transaction Counting）：追踪 TMA 传输了多少字节（仅 ClusterTransactionBarrier） Phase 位：用于区分不同轮次的同步 1.2 mbarrier 64-bit 结构 字段 位数 描述 Phase Bit 1 完成时翻转，用于区分不同轮次 Pending TX Count ~20 期望传输的字节数（TMA 完成时递减） Arrival Count ~20 剩余需要 arrive 的线程数 完成条件： 1Pending TX Count == 0 AND Arrival Count == 0 → Phase Bit 翻转 1.3 Phase-Parity 机制Phase 位是 mbarrier 实现循环复用的关键： Barrier 初始化时 phase = 0 当所有条件满足（到达计数和事务计数都归零），phase 翻转（0→1 或 1→0） try_wait.parity 指令检查当前 phase 是否匹配期望值 这样同一个 barrier 可以在不同迭代中重复使用 1.4 两种 Barrier 类型CUTLASS 定义了两种 barrier 类型： 类型 用途 完成条件 ClusterBarrier 纯到达计数 Arrival Count == 0 ClusterTransactionBarrier 到达 + 事务计数 Arrival Count == 0 AND TX Count == 0 源码位置：barrier.h 1.5 双 Barrier 架构Pipeline 使用双 Barrier 实现生产者-消费者同步： graph LR subgraph \"Pipeline Stage [i]\" FB[FullBarrierClusterTransactionBarrier] EB[EmptyBarrierClusterBarrier] BUF[(SMEM Buffer)] end subgraph Producer P1[producer_acquire] P2[TMA Load] P3[TMA Complete] end subgraph Consumer C1[consumer_wait] C2[MMA Compute] C3[consumer_release] end P1 -->|wait| EB P1 -->|arrive_and_expect_tx| FB P2 -->|write| BUF P3 -->|complete_tx| FB C1 -->|wait| FB BUF -->|read| C2 C3 -->|arrive| EB style FB fill:#e1f5fe style EB fill:#fff3e0 Barrier 类型 谁 Signal 谁 Wait 含义 FullBarrier ClusterTransactionBarrier Producer (TMA) Consumer “Data is ready” EmptyBarrier ClusterBarrier Consumer Producer “Buffer is free” 2. PipelineState 详解PipelineState 是 Pipeline 的状态追踪器，管理循环缓冲区中的当前位置。 2.1 数据结构定义12345678910111213141516171819// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:170-250template&lt;uint32_t Stages_&gt;struct PipelineState { static constexpr uint32_t Stages = Stages_; int index_ = 0; // 当前 stage 索引 (0 到 Stages-1) uint32_t phase_ = 0; // 当前 phase (0 或 1)，每绕回一次翻转 uint32_t count_ = 0; // 总迭代次数 CUTLASS_DEVICE PipelineState(): index_{}, phase_{}, count_{} {} CUTLASS_DEVICE PipelineState(int index, uint32_t phase, uint32_t count) : index_(index) , phase_(phase) , count_(count) {}}; 2.2 成员变量说明 成员 类型 描述 index_ int 当前 stage 在循环缓冲区中的索引，范围 [0, Stages-1] phase_ uint32_t 当前 phase 值，0 或 1，用于 barrier 同步 count_ uint32_t 总迭代计数，用于追踪已处理多少次 2.3 自增操作符123456789101112// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:203-213CUTLASS_DEVICEvoid operator++() { if constexpr (Stages &gt; 0) { ++index_; ++count_; if (index_ == Stages) { index_ = 0; // 回绕到开头 phase_ ^= 1; // 翻转 phase } }} 关键点：当 index_ 从 Stages-1 回绕到 0 时，phase_ 翻转。这确保了 barrier 能区分不同轮次的操作。 stateDiagram-v2 direction LR state \"Stage 0\" as S0 state \"Stage 1\" as S1 state \"Stage 2\" as S2 state \"Stage 3\" as S3 [*] --> S0: index=0, phase=0 S0 --> S1: ++index S1 --> S2: ++index S2 --> S3: ++index S3 --> S0: index回绕, phase翻转 note right of S3 当 index == Stages 时: index = 0 phase ^= 1 end note 2.4 advance 方法12345678910111213141516// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:228-244CUTLASS_DEVICEPipelineState&amp; advance(uint32_t num_iterations) { if constexpr (Stages &gt; 0) { // 判断是否需要翻转 phase if ((num_iterations &lt; Stages) &amp;&amp; (index_ + num_iterations) &gt;= Stages ) { phase_ ^= 1; } if ((num_iterations &gt;= Stages) &amp;&amp; (((index_ + num_iterations) / Stages) % 2) == 1) { phase_ ^= 1; } index_ = (index_ + num_iterations) % Stages; count_ += num_iterations; } return *this;} 2.5 访问器方法123CUTLASS_DEVICE int index() const { return index_; }CUTLASS_DEVICE uint32_t phase() const { return phase_; }CUTLASS_DEVICE uint32_t count() const { return count_; } 2.6 Producer 起始状态12345678910// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:252-260template&lt;class Pipeline&gt;CUTLASS_DEVICEPipelineState&lt;Pipeline::Stages&gt; make_producer_start_state() { // Producer 以相反的 phase 开始，因为缓冲区初始为空 constexpr int InitialProducerStage = 0; constexpr uint32_t InitialProducerPhase = 1; // 注意：phase 为 1 constexpr uint32_t InitialProducerCount = 0; return {InitialProducerStage, InitialProducerPhase, InitialProducerCount};} 重要：Producer 初始 phase 为 1，而 Consumer 初始 phase 为 0。这是因为缓冲区一开始是空的，Producer 需要先填充数据。 3. PipelineTmaAsync 详解PipelineTmaAsync 是 SM90 上用于 TMA 异步加载的 Pipeline 类，实现了生产者-消费者同步模式。 源码位置：sm90_pipeline.hpp 3.1 类型定义123456789101112// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:270-278template &lt;int Stages_&gt;class PipelineTmaAsync {public: using FullBarrier = cutlass::arch::ClusterTransactionBarrier; using EmptyBarrier = cutlass::arch::ClusterBarrier; using ProducerBarrierType = FullBarrier::ValueType; // uint64_t using ConsumerBarrierType = EmptyBarrier::ValueType; // uint64_t static constexpr uint32_t Stages = Stages_; using PipelineState = cutlass::PipelineState&lt;Stages&gt;; // ...}; 类型别名 实际类型 用途 FullBarrier ClusterTransactionBarrier 数据就绪信号，支持事务计数 EmptyBarrier ClusterBarrier 空间释放信号，纯到达计数 ProducerBarrierType uint64_t Full barrier 的原始值类型 ConsumerBarrierType uint64_t Empty barrier 的原始值类型 3.2 SharedStorage 结构12345// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:280-283struct SharedStorage { FullBarrier full_barrier_[Stages]; // 每个 stage 一个 full barrier EmptyBarrier empty_barrier_[Stages]; // 每个 stage 一个 empty barrier}; 每个 Pipeline stage 都有一对 barrier： full_barrier_：Producer 填充数据后 signal，Consumer 等待 empty_barrier_：Consumer 使用完毕后 signal，Producer 等待 graph TB subgraph \"SharedStorage (SMEM)\" subgraph \"Stage 0\" FB0[full_barrier_0] EB0[empty_barrier_0] end subgraph \"Stage 1\" FB1[full_barrier_1] EB1[empty_barrier_1] end subgraph \"Stage 2\" FB2[full_barrier_2] EB2[empty_barrier_2] end subgraph \"Stage N-1\" FBN[full_barrier_N-1] EBN[empty_barrier_N-1] end end FULL[full_barrier_ptr_] --> FB0 EMPTY[empty_barrier_ptr_] --> EB0 style FB0 fill:#e3f2fd style FB1 fill:#e3f2fd style FB2 fill:#e3f2fd style FBN fill:#e3f2fd style EB0 fill:#fff8e1 style EB1 fill:#fff8e1 style EB2 fill:#fff8e1 style EBN fill:#fff8e1 3.3 ThreadCategory 枚举1234567// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:285-290enum class ThreadCategory { NonParticipant, // 不参与 Pipeline 操作 Producer, // 仅作为生产者 Consumer, // 仅作为消费者 ProducerConsumer // 同时是生产者和消费者}; 3.4 Params 参数结构123456789// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:292-299struct Params { uint32_t transaction_bytes = 0; // 每次 TMA 传输的字节数 ThreadCategory role = ThreadCategory::NonParticipant; // 线程角色 uint32_t is_leader = 0; // 是否为 leader 线程（负责 barrier 操作） uint32_t num_consumers = 0; // Consumer 线程总数 uint32_t num_producers = 1; // Producer 线程总数 int initializing_warp = 0; // 负责初始化 barrier 的 warp}; 3.5 私有成员变量1234567// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:494-499private: uint32_t dst_blockid_ = 0; // 目标 CTA ID（用于 cluster 内通信） uint32_t is_signaling_thread_ = 0; // 是否负责发送 arrive 信号 FullBarrier *full_barrier_ptr_ = nullptr; // 指向 full barrier 数组 EmptyBarrier *empty_barrier_ptr_ = nullptr; // 指向 empty barrier 数组 Params params_; // 配置参数 成员 描述 dst_blockid_ 在 cluster 模式下，标识要发送 arrive 信号的目标 CTA is_signaling_thread_ 标记此线程是否负责发送 arrive 信号（避免重复发送） full_barrier_ptr_ 指向共享内存中 FullBarrier 数组的指针 empty_barrier_ptr_ 指向共享内存中 EmptyBarrier 数组的指针 params_ 保存构造时传入的配置参数 3.6 构造函数1234567891011121314151617181920212223242526272829303132// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:326-377template&lt;class ClusterShape, class InitBarriers, class InitMasks&gt;CUTLASS_DEVICEPipelineTmaAsync(SharedStorage&amp; storage, Params params, ClusterShape cluster_shape, InitBarriers = {}, InitMasks = {}) : params_(params) , full_barrier_ptr_(&amp;storage.full_barrier_[0]) , empty_barrier_ptr_(&amp;storage.empty_barrier_[0]) { int warp_idx = canonical_warp_idx_sync(); int thread_idx = threadIdx.x; // 初始化 barrier（如果需要） if constexpr (cute::is_same_v&lt;InitBarriers, cute::true_type&gt;) { init_barriers(storage, params_, cluster_shape); } // 初始化信号掩码（用于 cluster 内通信） if constexpr (cute::is_same_v&lt;InitMasks, cute::true_type&gt;) { dim3 block_id = cute::block_id_in_cluster(); auto cluster_size = cute::size(cluster_shape); if (cluster_size == 1) { is_signaling_thread_ = true; dst_blockid_ = 0; } else { // 在 warp group 内分配 arrive 职责 // ... } }} 3.7 Barrier 初始化12345678910111213141516171819202122232425// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:301-324template &lt;class ClusterShape&gt;static CUTLASS_DEVICE voidinit_barriers(SharedStorage&amp; storage, Params params, ClusterShape cluster_shape) { int warp_idx = canonical_warp_idx_sync(); bool is_initializing_warp = (warp_idx == params.initializing_warp); if (is_initializing_warp) { uint32_t const producer_arv_cnt = params.num_producers; uint32_t multicast_consumer_arrival_count = params.num_consumers; // Cluster 模式下调整 arrival count if (cute::size(cluster_shape) &gt; 1) { uint32_t const num_consumer_warpgroups_per_cluster = cute::ceil_div(params.num_consumers, NumThreadsPerWarpGroup); multicast_consumer_arrival_count = (cute::size&lt;0&gt;(cluster_shape) + cute::size&lt;1&gt;(cluster_shape) - 1) * num_consumer_warpgroups_per_cluster; } // 初始化 barrier 对 initialize_barrier_array_pair_aligned(...); } cutlass::arch::fence_barrier_init();} 4. Producer API 详解4.1 producer_try_acquire非阻塞尝试获取缓冲区空间： 12345678910111213141516// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:419-422 (public)CUTLASS_DEVICEProducerToken producer_try_acquire(PipelineState state, uint32_t skip_wait = false) { return producer_try_acquire(state.index(), state.phase(), skip_wait);}// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:501-509 (private)CUTLASS_DEVICEProducerToken producer_try_acquire(uint32_t stage, uint32_t phase, uint32_t skip_wait) { detail::pipeline_check_is_producer(params_.role); if (skip_wait) { return {BarrierStatus::WaitDone}; } bool barrier_status = empty_barrier_ptr_[stage].try_wait(phase); return {static_cast&lt;BarrierStatus&gt;(barrier_status)};} PTX 指令： 12mbarrier.try_wait.parity.shared::cta.b64 P1, [smem_addr], phase;selp.b32 result, 1, 0, P1; 4.2 producer_acquire阻塞等待缓冲区空间，并设置期望传输字节数： 1234567891011121314151617// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:424-427 (public)CUTLASS_DEVICEvoid producer_acquire(PipelineState state) { producer_acquire(state.index(), state.phase());}// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:511-528 (private)CUTLASS_DEVICEvoid producer_acquire(uint32_t stage, uint32_t phase) { // Step 1: 等待 Consumer 释放空间 empty_barrier_ptr_[stage].wait(phase); // Step 2: Leader 线程设置期望传输字节数 if (params_.is_leader) { full_barrier_ptr_[stage].arrive_and_expect_tx(params_.transaction_bytes); }} PTX 指令： 等待部分（spin loop）： 12345LAB_WAIT: mbarrier.try_wait.parity.shared::cta.b64 P1, [smem_addr], phase, 0x989680; @P1 bra DONE; bra LAB_WAIT;DONE: 设置期望字节数： 1mbarrier.arrive.expect_tx.shared::cta.b64 _, [smem_addr], transaction_bytes; 4.3 producer_acquire (带 token)12345678910111213// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:530-550CUTLASS_DEVICEvoid producer_acquire(uint32_t stage, uint32_t phase, ProducerToken barrier_token) { detail::pipeline_check_is_producer(params_.role); // 如果 try_acquire 已经成功，跳过等待 if (barrier_token != BarrierStatus::WaitDone) { empty_barrier_ptr_[stage].wait(phase); } if (params_.is_leader) { full_barrier_ptr_[stage].arrive_and_expect_tx(params_.transaction_bytes); }} 4.4 producer_expect_transaction额外增加期望传输字节数（用于多次 TMA 操作）： 12345678// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:552-558CUTLASS_DEVICEvoid producer_expect_transaction(uint32_t stage, uint32_t transaction_bytes) { detail::pipeline_check_is_producer(params_.role); if (params_.is_leader) { full_barrier_ptr_[stage].expect_transaction(transaction_bytes); }} PTX 指令： 1mbarrier.expect_tx.shared::cta.b64 [smem_addr], transaction_bytes; 4.5 producer_commitTMA 完成后由硬件自动触发： 1234567891011// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:560-587CUTLASS_DEVICEvoid producer_commit(uint32_t stage, uint32_t bytes) { // 仅用于单元测试（无 TMA 时手动提交） #if CUTLASS_UNIT_TEST_PIPELINE if (params_.is_leader) { full_barrier_ptr_[stage].complete_transaction(bytes); // Cluster 模式下通知其他 CTA... } #endif} PTX 指令（TMA 硬件自动执行）： 1mbarrier.complete_tx.shared::cluster.relaxed.cluster.b64 [smem_addr], transaction_bytes; 4.6 producer_get_barrier返回 barrier 指针供 TMA 使用： 12345// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:638-641CUTLASS_DEVICEProducerBarrierType* producer_get_barrier(uint32_t stage) { return reinterpret_cast&lt;ProducerBarrierType*&gt;(&amp;full_barrier_ptr_[stage]);} 4.7 producer_tail防止 Producer block 过早退出： 123456789// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:447-454CUTLASS_DEVICEvoid producer_tail(PipelineState state) { detail::pipeline_check_is_producer(params_.role); for (int count = 0; count &lt; Stages; ++count) { empty_barrier_ptr_[state.index()].wait(state.phase()); ++state; }} 5. Consumer API 详解5.1 consumer_try_wait非阻塞尝试等待数据就绪： 12345678910// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:590-597CUTLASS_DEVICEConsumerToken consumer_try_wait(uint32_t stage, uint32_t phase, uint32_t skip_wait) { detail::pipeline_check_is_consumer(params_.role); if (skip_wait) { return {BarrierStatus::WaitDone}; } bool barrier_status = full_barrier_ptr_[stage].try_wait(phase); return {static_cast&lt;BarrierStatus&gt;(barrier_status)};} 返回值： BarrierStatus::WaitDone (1)：数据已就绪 BarrierStatus::WaitAgain (0)：数据未就绪 5.2 consumer_test_wait与 try_wait 类似，但使用 test_wait PTX 指令： 12345678910// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:599-607CUTLASS_DEVICEConsumerToken consumer_test_wait(uint32_t stage, uint32_t phase, uint32_t skip_wait) { detail::pipeline_check_is_consumer(params_.role); if (skip_wait) { return {BarrierStatus::WaitDone}; } bool barrier_status = full_barrier_ptr_[stage].test_wait(phase); return {static_cast&lt;BarrierStatus&gt;(barrier_status)};} 5.3 consumer_wait阻塞等待数据就绪： 12345678910111213141516// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:609-623CUTLASS_DEVICEvoid consumer_wait(uint32_t stage, uint32_t phase) { detail::pipeline_check_is_consumer(params_.role); full_barrier_ptr_[stage].wait(phase);}// 带 token 版本CUTLASS_DEVICEvoid consumer_wait(uint32_t stage, uint32_t phase, ConsumerToken barrier_token) { detail::pipeline_check_is_consumer(params_.role); if (barrier_token == BarrierStatus::WaitAgain) { full_barrier_ptr_[stage].wait(phase); } // 如果已经 WaitDone，直接返回} 5.4 consumer_release通知 Producer 空间已释放： 123456// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:625-636CUTLASS_DEVICEvoid consumer_release(uint32_t stage, uint32_t skip = false) { detail::pipeline_check_is_consumer(params_.role); empty_barrier_ptr_[stage].arrive(dst_blockid_, is_signaling_thread_ &amp; (!skip));} PTX 指令： 本地 CTA arrive： 1mbarrier.arrive.shared::cta.b64 _, [smem_addr]; 远程 Cluster arrive： 12mapa.shared::cluster.u32 remAddr32, smem_addr, cta_id;mbarrier.arrive.shared::cluster.b64 _, [remAddr32]; 6. Pipeline API 到 PTX 映射总览 Pipeline API Barrier 类型 PTX 指令 producer_try_acquire EmptyBarrier mbarrier.try_wait.parity (单次) producer_acquire (wait) EmptyBarrier mbarrier.try_wait.parity (spin) producer_acquire (leader) FullBarrier mbarrier.arrive.expect_tx producer_expect_transaction FullBarrier mbarrier.expect_tx producer_commit FullBarrier mbarrier.complete_tx (TMA 自动) consumer_try_wait FullBarrier mbarrier.try_wait.parity (单次) consumer_test_wait FullBarrier mbarrier.test_wait.parity consumer_wait FullBarrier mbarrier.try_wait.parity (spin) consumer_release EmptyBarrier mbarrier.arrive 7. ClusterBarrier 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 源码: include/cutlass/arch/barrier.h:341-532struct ClusterBarrier { using ValueType = uint64_t;protected: ValueType barrier_; // SMEM 中的 64-bit mbarrier 对象public: // 初始化 barrier static void init(ValueType const* smem_ptr, uint32_t arrive_count) { uint32_t smem_addr = cute::cast_smem_ptr_to_uint(smem_ptr); asm volatile( &quot;mbarrier.init.shared::cta.b64 [%1], %0;&quot; : : &quot;r&quot;(arrive_count), &quot;r&quot;(smem_addr)); } // 阻塞等待（spin loop） static void wait(ValueType const* smem_ptr, uint32_t phase) { uint32_t smem_addr = cute::cast_smem_ptr_to_uint(smem_ptr); uint32_t ticks = 0x989680; // ~10M cycles 超时后重试 asm volatile( &quot;.reg .pred P1;\\n&quot; &quot;LAB_WAIT:\\n&quot; &quot;mbarrier.try_wait.parity.shared::cta.b64 P1, [%0], %1, %2;\\n&quot; &quot;@P1 bra DONE;\\n&quot; &quot;bra LAB_WAIT;\\n&quot; &quot;DONE:&quot; : : &quot;r&quot;(smem_addr), &quot;r&quot;(phase), &quot;r&quot;(ticks)); } // 非阻塞尝试等待 static bool try_wait(ValueType const* smem_ptr, uint32_t phase) { uint32_t smem_addr = cute::cast_smem_ptr_to_uint(smem_ptr); uint32_t waitComplete; asm volatile( &quot;.reg .pred P1;\\n&quot; &quot;mbarrier.try_wait.parity.shared::cta.b64 P1, [%1], %2;\\n&quot; &quot;selp.b32 %0, 1, 0, P1;&quot; : &quot;=r&quot;(waitComplete) : &quot;r&quot;(smem_addr), &quot;r&quot;(phase)); return static_cast&lt;bool&gt;(waitComplete); } // 本地 arrive static void arrive(ValueType const* smem_ptr) { uint32_t smem_addr = cute::cast_smem_ptr_to_uint(smem_ptr); asm volatile( &quot;mbarrier.arrive.shared::cta.b64 _, [%0];&quot; : : &quot;r&quot;(smem_addr)); } // 远程 cluster arrive static void arrive(ValueType const* smem_ptr, uint32_t cta_id, uint32_t pred) { uint32_t smem_addr = cute::cast_smem_ptr_to_uint(smem_ptr); if (pred) { asm volatile( &quot;.reg .b32 remAddr32;\\n&quot; &quot;mapa.shared::cluster.u32 remAddr32, %0, %1;\\n&quot; &quot;mbarrier.arrive.shared::cluster.b64 _, [remAddr32];&quot; : : &quot;r&quot;(smem_addr), &quot;r&quot;(cta_id)); } }}; 8. ClusterTransactionBarrier 实现1234567891011121314151617181920212223242526272829303132// 源码: include/cutlass/arch/barrier.h:538-693struct ClusterTransactionBarrier : public ClusterBarrier { // Arrive + 设置期望传输字节数 static void arrive_and_expect_tx(ValueType const* smem_ptr, uint32_t transaction_bytes) { uint32_t smem_addr = cute::cast_smem_ptr_to_uint(smem_ptr); asm volatile( &quot;mbarrier.arrive.expect_tx.shared::cta.b64 _, [%1], %0;&quot; : : &quot;r&quot;(transaction_bytes), &quot;r&quot;(smem_addr)); } // 仅设置期望字节数（不 arrive） static void expect_transaction(ValueType const* smem_ptr, uint32_t transaction_bytes) { uint32_t smem_addr = cute::cast_smem_ptr_to_uint(smem_ptr); asm volatile( &quot;mbarrier.expect_tx.shared::cta.b64 [%1], %0;&quot; : : &quot;r&quot;(transaction_bytes), &quot;r&quot;(smem_addr)); } // 完成传输（减少 pending 字节数）- TMA 硬件自动调用 static void complete_transaction( ValueType const* smem_ptr, uint32_t dst_cta_id, uint32_t transaction_bytes, uint32_t pred = 1) { uint32_t smem_addr = cute::cast_smem_ptr_to_uint(smem_ptr); smem_addr = cute::set_block_rank(smem_addr, dst_cta_id); asm volatile( &quot;.reg .pred p;\\n&quot; &quot;setp.eq.u32 p, %2, 1;\\n&quot; &quot;@p mbarrier.complete_tx.shared::cluster.relaxed.cluster.b64 [%1], %0;&quot; : : &quot;r&quot;(transaction_bytes), &quot;r&quot;(smem_addr), &quot;r&quot;(pred)); }}; 9. 完整工作流程示例下图展示了 Producer 和 Consumer 之间的交互时序： sequenceDiagram participant P as Producer participant FB as FullBarrier participant EB as EmptyBarrier participant BUF as SMEM Buffer participant C as Consumer Note over P,C: Stage i 的一次完整迭代 rect rgb(232, 245, 233) Note over P: Producer Phase P->>EB: wait(phase) - 等待空间 EB-->>P: 空间已释放 P->>FB: arrive_and_expect_tx(bytes) P->>BUF: TMA Load (异步) Note over FB: TMA完成后自动complete_tx end rect rgb(227, 242, 253) Note over C: Consumer Phase C->>FB: wait(phase) - 等待数据 FB-->>C: 数据已就绪 BUF->>C: 读取数据 Note over C: MMA 计算 C->>EB: arrive() - 释放空间 end Note over P,C: Phase 翻转后进入下一轮 12345678910111213141516171819202122232425262728293031323334353637383940// Producer 线程（TMA 加载器）PipelineState producer_state = make_producer_start_state&lt;Pipeline&gt;();for (int k = 0; k &lt; num_tiles; ++k) { // 1. 获取缓冲区（等待空间 + 设置期望字节数） pipeline.producer_acquire(producer_state); // 2. 获取 barrier 指针供 TMA 使用 auto* barrier = pipeline.producer_get_barrier(producer_state); // 3. 发起 TMA 加载（硬件自动完成 barrier） copy(tma_load, gmem_tensor, smem_tensor, barrier); ++producer_state;}// 4. 退出前等待所有 Consumer 完成pipeline.producer_tail(producer_state);// Consumer 线程（MMA 计算）PipelineState consumer_state{0, 0, 0}; // phase = 0for (int k = 0; k &lt; num_tiles; ++k) { // 1. 尝试等待（非阻塞） auto token = pipeline.consumer_try_wait(consumer_state); // 2. 可以做一些其他工作... // 3. 如果需要，阻塞等待 pipeline.consumer_wait(consumer_state, token); // 4. 使用 SMEM 数据进行 MMA 计算 gemm(smem_tensor, accumulators); // 5. 释放缓冲区给 Producer pipeline.consumer_release(consumer_state); ++consumer_state;} 10. 关键要点总结 SM90 专属：Pipeline 机制专为 NVIDIA Hopper 架构（SM90+）设计 双 Barrier 架构： FullBarrier（ClusterTransactionBarrier）：Producer → Consumer，数据就绪信号 EmptyBarrier（ClusterBarrier）：Consumer → Producer，空间释放信号 硬件加速：TMA 完成时自动 signal barrier，无需软件干预 Phase 机制：phase 位使 barrier 可跨迭代复用 Cluster 支持：通过 mapa 指令实现跨 CTA 的 barrier 操作 Leader 模式：只有 leader 线程执行 barrier 的 arrive/expect_tx 操作，避免重复 参考资料 CUTLASS GitHub 仓库 sm90_pipeline.hpp barrier.h NVIDIA PTX ISA - mbarrier CUDA Programming Guide - Asynchronous Barrier","link":"/2024/12/23/pipeline-barrier-ptx-mapping/"}],"tags":[{"name":"CUTLASS","slug":"CUTLASS","link":"/tags/CUTLASS/"},{"name":"Pipeline","slug":"Pipeline","link":"/tags/Pipeline/"},{"name":"mbarrier","slug":"mbarrier","link":"/tags/mbarrier/"},{"name":"PTX","slug":"PTX","link":"/tags/PTX/"},{"name":"SM90","slug":"SM90","link":"/tags/SM90/"}],"categories":[{"name":"CUTLASS","slug":"CUTLASS","link":"/categories/CUTLASS/"}],"pages":[{"title":"关于","text":"关于本站这是一个专注于 NVIDIA CUTLASS 和 CuTE 内部实现的学习笔记站点。 内容涵盖 Pipeline 同步机制: mbarrier、双 Barrier 架构、PTX 指令映射 Epilogue 融合: EVT (Expression Visitor Tree)、FusionCallbacks CuTE Tensor: Layout、Stride、TMA 联系方式 GitHub: DrXuQian","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"","text":"/* Custom styles for wider page width */ /* ===== Dark Mode Theme Toggle ===== */ /* Theme toggle button in navbar */ .theme-toggle { cursor: pointer; padding: 0.5rem; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; color: inherit; background: transparent; border: none; transition: transform 0.3s ease; } .theme-toggle:hover { transform: scale(1.1); } .theme-toggle .icon-sun, .theme-toggle .icon-moon { display: none; } /* Light mode: show moon icon */ html:not([data-theme=\"dark\"]) .theme-toggle .icon-moon { display: inline; } /* Dark mode: show sun icon */ html[data-theme=\"dark\"] .theme-toggle .icon-sun { display: inline; } /* ===== Dark Mode Styles ===== */ html[data-theme=\"dark\"] { --bg-color: #1a1a2e; --bg-color-secondary: #16213e; --text-color: #e4e4e4; --text-color-secondary: #a0a0a0; --border-color: #2d2d4a; --card-bg: #1f1f38; --link-color: #6c9fff; --link-hover: #99b8ff; --code-bg: #0d1117; } html[data-theme=\"dark\"] body { background-color: var(--bg-color) !important; color: var(--text-color) !important; } html[data-theme=\"dark\"] .navbar { background-color: var(--bg-color-secondary) !important; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); } html[data-theme=\"dark\"] .navbar-item, html[data-theme=\"dark\"] .navbar-link { color: var(--text-color) !important; } html[data-theme=\"dark\"] .navbar-item:hover, html[data-theme=\"dark\"] .navbar-link:hover { background-color: rgba(255, 255, 255, 0.1) !important; color: var(--link-color) !important; } html[data-theme=\"dark\"] .card { background-color: var(--card-bg) !important; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3) !important; } html[data-theme=\"dark\"] .card-content { background-color: var(--card-bg) !important; } html[data-theme=\"dark\"] .title, html[data-theme=\"dark\"] .subtitle, html[data-theme=\"dark\"] h1, html[data-theme=\"dark\"] h2, html[data-theme=\"dark\"] h3, html[data-theme=\"dark\"] h4, html[data-theme=\"dark\"] h5, html[data-theme=\"dark\"] h6 { color: var(--text-color) !important; } html[data-theme=\"dark\"] .content { color: var(--text-color) !important; } html[data-theme=\"dark\"] a { color: var(--link-color) !important; } html[data-theme=\"dark\"] a:hover { color: var(--link-hover) !important; } html[data-theme=\"dark\"] .menu-label { color: var(--text-color-secondary) !important; } html[data-theme=\"dark\"] .menu-list a { color: var(--text-color) !important; } html[data-theme=\"dark\"] .menu-list a:hover { background-color: rgba(255, 255, 255, 0.05) !important; color: var(--link-color) !important; } html[data-theme=\"dark\"] .tag { background-color: var(--border-color) !important; color: var(--text-color) !important; } html[data-theme=\"dark\"] .footer { background-color: var(--bg-color-secondary) !important; color: var(--text-color-secondary) !important; } html[data-theme=\"dark\"] .widget { background-color: var(--card-bg) !important; } html[data-theme=\"dark\"] pre, html[data-theme=\"dark\"] code { background-color: var(--code-bg) !important; } html[data-theme=\"dark\"] .hljs { background-color: var(--code-bg) !important; } html[data-theme=\"dark\"] .article-meta, html[data-theme=\"dark\"] .level-item { color: var(--text-color-secondary) !important; } html[data-theme=\"dark\"] .button.is-primary { background-color: #3273dc !important; } html[data-theme=\"dark\"] .input, html[data-theme=\"dark\"] .textarea, html[data-theme=\"dark\"] .select select { background-color: var(--bg-color-secondary) !important; border-color: var(--border-color) !important; color: var(--text-color) !important; } html[data-theme=\"dark\"] .pagination-link, html[data-theme=\"dark\"] .pagination-previous, html[data-theme=\"dark\"] .pagination-next { background-color: var(--card-bg) !important; border-color: var(--border-color) !important; color: var(--text-color) !important; } html[data-theme=\"dark\"] .toc-list a { color: var(--text-color) !important; } html[data-theme=\"dark\"] .toc-list a:hover, html[data-theme=\"dark\"] .toc-list a.is-active { color: var(--link-color) !important; } html[data-theme=\"dark\"] hr { background-color: var(--border-color) !important; } html[data-theme=\"dark\"] blockquote { background-color: var(--bg-color-secondary) !important; border-left-color: var(--link-color) !important; } html[data-theme=\"dark\"] table th, html[data-theme=\"dark\"] table td { border-color: var(--border-color) !important; } html[data-theme=\"dark\"] table thead th { background-color: var(--bg-color-secondary) !important; color: var(--text-color) !important; } html[data-theme=\"dark\"] table tbody tr:nth-child(even) { background-color: rgba(255, 255, 255, 0.02) !important; } /* ===== End Dark Mode Styles ===== */ /* ===== Hide right sidebar on post pages ===== */ body.is-post-page .column.column-right { display: none !important; } /* When right sidebar is hidden, expand main content */ body.is-post-page .column.column-main.is-8-tablet.is-8-desktop.is-6-widescreen { width: 70% !important; flex: none !important; } body.is-post-page .column.column-left.is-4-tablet.is-4-desktop.is-3-widescreen { width: 30% !important; flex: none !important; } /* For two-column layout on post pages */ body.is-post-page .columns { justify-content: center; } /* ===== End Hide Right Sidebar ===== */ /* Increase container max-width */ html body .container { max-width: 1600px !important; } /* Main content column - wider */ html body .column.is-8-tablet, html body .column.is-8-desktop, html body .column.is-8-widescreen, html body .is-8-desktop, html body .is-8-widescreen { flex: none !important; width: 70% !important; } /* Sidebar column - narrower */ html body .column.is-4-tablet, html body .column.is-4-desktop, html body .column.is-4-widescreen, html body .is-4-desktop, html body .is-4-widescreen { flex: none !important; width: 30% !important; } /* Two sidebar layout - left sidebar smaller */ html body .column.is-8-tablet.is-8-desktop.is-6-widescreen { width: 55% !important; flex: none !important; } html body .column.is-4-tablet.is-4-desktop.is-3-widescreen { width: 22.5% !important; flex: none !important; } /* Card content padding */ html body .card-content { padding: 1.25rem 1.5rem; } /* Code block */ html body .content pre { max-width: 100%; overflow-x: auto; } /* Article content */ html body .article-content { max-width: 100%; } /* Large screens */ @media screen and (min-width: 1408px) { html body .container { max-width: 1700px !important; } } @media screen and (min-width: 1600px) { html body .container { max-width: 1900px !important; } } @media screen and (min-width: 1800px) { html body .container { max-width: 2100px !important; } html body .column.is-8-desktop, html body .column.is-8-widescreen { width: 72% !important; } html body .column.is-4-desktop, html body .column.is-4-widescreen { width: 28% !important; } }","link":"/css/custom.css"},{"title":"","text":"// Theme toggle functionality (function() { 'use strict'; // Detect if current page is a post page and add class to body function detectPostPage() { // Check if URL matches post pattern (e.g., /2024/12/23/post-name/) const path = window.location.pathname; const isPost = /^\\/\\d{4}\\/\\d{2}\\/\\d{2}\\//.test(path); if (isPost) { document.body.classList.add('is-post-page'); } else { document.body.classList.remove('is-post-page'); } } // Get saved theme or default to light function getTheme() { return localStorage.getItem('theme') || 'light'; } // Apply theme to document function applyTheme(theme) { if (theme === 'dark') { document.documentElement.setAttribute('data-theme', 'dark'); } else { document.documentElement.removeAttribute('data-theme'); } } // Save theme preference function saveTheme(theme) { localStorage.setItem('theme', theme); } // Toggle between light and dark function toggleTheme() { const currentTheme = getTheme(); const newTheme = currentTheme === 'dark' ? 'light' : 'dark'; applyTheme(newTheme); saveTheme(newTheme); } // Create and inject toggle button into navbar function createToggleButton() { const navbarEnd = document.querySelector('.navbar-end'); if (!navbarEnd) return; // Check if button already exists if (document.querySelector('.theme-toggle')) return; const toggleBtn = document.createElement('a'); toggleBtn.className = 'navbar-item theme-toggle'; toggleBtn.title = 'Toggle Dark Mode'; toggleBtn.innerHTML = ''; toggleBtn.addEventListener('click', function(e) { e.preventDefault(); toggleTheme(); }); // Insert before the search button const searchBtn = navbarEnd.querySelector('.search'); if (searchBtn) { navbarEnd.insertBefore(toggleBtn, searchBtn); } else { navbarEnd.appendChild(toggleBtn); } } // Initialize on page load function init() { // Apply saved theme immediately applyTheme(getTheme()); // Detect post page and hide right sidebar detectPostPage(); // Create toggle button when DOM is ready if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', createToggleButton); } else { createToggleButton(); } } // Apply theme immediately to prevent flash applyTheme(getTheme()); // Run init when DOM is ready if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); } else { init(); } // Re-create button and detect page type after pjax navigation (Icarus uses pjax) document.addEventListener('pjax:complete', function() { createToggleButton(); detectPostPage(); }); })();","link":"/js/theme-toggle.js"}]}