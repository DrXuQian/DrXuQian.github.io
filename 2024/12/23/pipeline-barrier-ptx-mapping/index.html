<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>CUTLASS SM90 Pipeline 与 mbarrier 深度解析 - CUTLASS 学习笔记</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#0d1117"><meta name="application-name" content="CUTLASS 学习笔记"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="msapplication-TileColor" content="#0d1117"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="CUTLASS 学习笔记"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本文深入解析 CUTLASS SM90 Pipeline 机制及其底层 mbarrier PTX 指令的映射关系。所有代码引用均来自 NVIDIA CUTLASS 官方仓库。"><meta property="og:type" content="blog"><meta property="og:title" content="CUTLASS SM90 Pipeline 与 mbarrier 深度解析"><meta property="og:url" content="https://drxuqian.github.io/2024/12/23/pipeline-barrier-ptx-mapping/"><meta property="og:site_name" content="CUTLASS 学习笔记"><meta property="og:description" content="本文深入解析 CUTLASS SM90 Pipeline 机制及其底层 mbarrier PTX 指令的映射关系。所有代码引用均来自 NVIDIA CUTLASS 官方仓库。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://drxuqian.github.io/img/og_image.png"><meta property="article:published_time" content="2024-12-22T16:00:00.000Z"><meta property="article:modified_time" content="2025-12-23T22:10:21.641Z"><meta property="article:author" content="DrXuQian"><meta property="article:tag" content="CUTLASS"><meta property="article:tag" content="Pipeline"><meta property="article:tag" content="mbarrier"><meta property="article:tag" content="PTX"><meta property="article:tag" content="SM90"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://drxuqian.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://drxuqian.github.io/2024/12/23/pipeline-barrier-ptx-mapping/"},"headline":"CUTLASS SM90 Pipeline 与 mbarrier 深度解析","image":["https://drxuqian.github.io/img/og_image.png"],"datePublished":"2024-12-22T16:00:00.000Z","dateModified":"2025-12-23T22:10:21.641Z","author":{"@type":"Person","name":"DrXuQian"},"publisher":{"@type":"Organization","name":"CUTLASS 学习笔记","logo":{"@type":"ImageObject","url":"https://drxuqian.github.io/img/logo.svg"}},"description":"本文深入解析 CUTLASS SM90 Pipeline 机制及其底层 mbarrier PTX 指令的映射关系。所有代码引用均来自 NVIDIA CUTLASS 官方仓库。"}</script><link rel="canonical" href="https://drxuqian.github.io/2024/12/23/pipeline-barrier-ptx-mapping/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 8.1.1"><link rel="stylesheet" href="/css/custom.css"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="CUTLASS 学习笔记" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/DrXuQian"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-12-22T16:00:00.000Z" title="12/23/2024, 12:00:00 AM">2024-12-23</time>发表</span><span class="level-item"><time dateTime="2025-12-23T22:10:21.641Z" title="12/24/2025, 6:10:21 AM">2025-12-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/CUTLASS/">CUTLASS</a></span><span class="level-item">34 分钟读完 (大约5133个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">CUTLASS SM90 Pipeline 与 mbarrier 深度解析</h1><div class="content"><p>本文深入解析 CUTLASS SM90 Pipeline 机制及其底层 mbarrier PTX 指令的映射关系。所有代码引用均来自 NVIDIA CUTLASS 官方仓库。</p>
<span id="more"></span>

<h2 id="1-mbarrier-原理"><a href="#1-mbarrier-原理" class="headerlink" title="1. mbarrier 原理"></a>1. mbarrier 原理</h2><h3 id="1-1-什么是-mbarrier"><a href="#1-1-什么是-mbarrier" class="headerlink" title="1.1 什么是 mbarrier"></a>1.1 什么是 mbarrier</h3><p><code>mbarrier</code>（Memory Barrier）是 NVIDIA Hopper (SM90) 架构引入的硬件同步原语，存储在共享内存（SMEM）中。它是一个 64-bit 的硬件对象，支持：</p>
<ul>
<li><strong>到达计数（Arrival Counting）</strong>：追踪有多少线程已经到达 barrier</li>
<li><strong>事务计数（Transaction Counting）</strong>：追踪 TMA 传输了多少字节（仅 <code>ClusterTransactionBarrier</code>）</li>
<li><strong>Phase 位</strong>：用于区分不同轮次的同步</li>
</ul>
<h3 id="1-2-mbarrier-64-bit-结构"><a href="#1-2-mbarrier-64-bit-结构" class="headerlink" title="1.2 mbarrier 64-bit 结构"></a>1.2 mbarrier 64-bit 结构</h3><table>
<thead>
<tr>
<th>字段</th>
<th>位数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Phase Bit</td>
<td>1</td>
<td>完成时翻转，用于区分不同轮次</td>
</tr>
<tr>
<td>Pending TX Count</td>
<td>~20</td>
<td>期望传输的字节数（TMA 完成时递减）</td>
</tr>
<tr>
<td>Arrival Count</td>
<td>~20</td>
<td>剩余需要 arrive 的线程数</td>
</tr>
</tbody></table>
<p><strong>完成条件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pending TX Count == 0 AND Arrival Count == 0 → Phase Bit 翻转</span><br></pre></td></tr></table></figure>

<h3 id="1-3-Phase-Parity-机制"><a href="#1-3-Phase-Parity-机制" class="headerlink" title="1.3 Phase-Parity 机制"></a>1.3 Phase-Parity 机制</h3><p>Phase 位是 mbarrier 实现循环复用的关键：</p>
<ol>
<li>Barrier 初始化时 phase &#x3D; 0</li>
<li>当所有条件满足（到达计数和事务计数都归零），phase 翻转（0→1 或 1→0）</li>
<li><code>try_wait.parity</code> 指令检查当前 phase 是否匹配期望值</li>
<li>这样同一个 barrier 可以在不同迭代中重复使用</li>
</ol>
<h3 id="1-4-两种-Barrier-类型"><a href="#1-4-两种-Barrier-类型" class="headerlink" title="1.4 两种 Barrier 类型"></a>1.4 两种 Barrier 类型</h3><p>CUTLASS 定义了两种 barrier 类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>用途</th>
<th>完成条件</th>
</tr>
</thead>
<tbody><tr>
<td><code>ClusterBarrier</code></td>
<td>纯到达计数</td>
<td>Arrival Count &#x3D;&#x3D; 0</td>
</tr>
<tr>
<td><code>ClusterTransactionBarrier</code></td>
<td>到达 + 事务计数</td>
<td>Arrival Count &#x3D;&#x3D; 0 AND TX Count &#x3D;&#x3D; 0</td>
</tr>
</tbody></table>
<p>源码位置：<a target="_blank" rel="noopener" href="https://github.com/NVIDIA/cutlass/blob/main/include/cutlass/arch/barrier.h">barrier.h</a></p>
<h3 id="1-5-双-Barrier-架构"><a href="#1-5-双-Barrier-架构" class="headerlink" title="1.5 双 Barrier 架构"></a>1.5 双 Barrier 架构</h3><p>Pipeline 使用双 Barrier 实现生产者-消费者同步：</p>
<pre class="mermaid">graph LR
    subgraph Producer["Producer (TMA Warp)"]
        P1[producer_acquire]
        P2[TMA Load]
        P1 --> P2
    end

    subgraph Stage["Pipeline Stage [i]"]
        EB[EmptyBarrier<br/>ClusterBarrier]
        BUF[(SMEM Buffer)]
        FB[FullBarrier<br/>ClusterTransactionBarrier]
    end

    subgraph Consumer["Consumer (MMA Warps)"]
        C1[consumer_wait]
        C2[MMA Compute]
        C3[consumer_release]
        C1 --> C2 --> C3
    end

    P1 -.->|1. wait| EB
    P1 -->|2. expect_tx| FB
    P2 -->|3. write| BUF
    P2 -->|4. complete_tx| FB

    C1 -.->|5. wait| FB
    BUF -->|6. read| C2
    C3 -->|7. arrive| EB

    style FB fill:#e1f5fe
    style EB fill:#fff3e0
    style BUF fill:#e8f5e9</pre>

<p><strong>图例说明</strong>：</p>
<ul>
<li>虚线 <code>-.-&gt;</code> 表示<strong>等待&#x2F;阻塞</strong>操作</li>
<li>实线 <code>--&gt;</code> 表示<strong>信号&#x2F;数据传输</strong>操作</li>
</ul>
<table>
<thead>
<tr>
<th>Barrier</th>
<th>类型</th>
<th>谁 Signal</th>
<th>谁 Wait</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>FullBarrier</strong></td>
<td><code>ClusterTransactionBarrier</code></td>
<td>Producer (TMA)</td>
<td>Consumer</td>
<td>“Data is ready”</td>
</tr>
<tr>
<td><strong>EmptyBarrier</strong></td>
<td><code>ClusterBarrier</code></td>
<td>Consumer</td>
<td>Producer</td>
<td>“Buffer is free”</td>
</tr>
</tbody></table>
<h3 id="1-6-Cluster-级别的-mbarrier-同步与-DSMEM"><a href="#1-6-Cluster-级别的-mbarrier-同步与-DSMEM" class="headerlink" title="1.6 Cluster 级别的 mbarrier 同步与 DSMEM"></a>1.6 Cluster 级别的 mbarrier 同步与 DSMEM</h3><p>mbarrier 存储在共享内存（SMEM）中，但 Hopper 架构引入的 <strong>Thread Block Cluster</strong> 和 <strong>Distributed Shared Memory (DSMEM)</strong> 机制使得跨 SM 的 barrier 同步成为可能。</p>
<h4 id="1-6-1-DSMEM-硬件架构"><a href="#1-6-1-DSMEM-硬件架构" class="headerlink" title="1.6.1 DSMEM 硬件架构"></a>1.6.1 DSMEM 硬件架构</h4><p>Hopper 引入了专用的 <strong>SM-to-SM 网络</strong>，使 Cluster 内的多个 SM 可以直接访问彼此的共享内存：</p>
<pre class="mermaid">graph TB
    subgraph GPC["Graphics Processing Cluster (GPC)"]
        subgraph SM0["SM 0 (CTA 0)"]
            SMEM0[SMEM<br/>mbarrier_0]
        end
        subgraph SM1["SM 1 (CTA 1)"]
            SMEM1[SMEM<br/>mbarrier_1]
        end
        subgraph SM2["SM 2 (CTA 2)"]
            SMEM2[SMEM<br/>mbarrier_2]
        end
        subgraph SM3["SM 3 (CTA 3)"]
            SMEM3[SMEM<br/>mbarrier_3]
        end

        NET[SM-to-SM Network<br/>Low Latency NOC]

        SM0 <--> NET
        SM1 <--> NET
        SM2 <--> NET
        SM3 <--> NET
    end

    style NET fill:#e3f2fd
    style SMEM0 fill:#fff8e1
    style SMEM1 fill:#fff8e1
    style SMEM2 fill:#fff8e1
    style SMEM3 fill:#fff8e1</pre>

<p><strong>关键特性</strong>：</p>
<ul>
<li><strong>专用互连</strong>：SM-to-SM 网络是独立于 L2 缓存的专用硬件通路</li>
<li><strong>低延迟</strong>：跨 SM 访问延迟约 180 cycles，比经过 L2（~956 cycles）快约 5.3 倍</li>
<li><strong>高带宽</strong>：2-block cluster 可达 ~3.27 TB&#x2F;s，4-block cluster 约 2.65 TB&#x2F;s</li>
<li><strong>并发使用</strong>：DSMEM 可与 L2 缓存同时使用，带宽可叠加</li>
</ul>
<h4 id="1-6-2-mapa-指令：跨-SM-地址映射"><a href="#1-6-2-mapa-指令：跨-SM-地址映射" class="headerlink" title="1.6.2 mapa 指令：跨 SM 地址映射"></a>1.6.2 mapa 指令：跨 SM 地址映射</h4><p>要访问其他 SM 的共享内存，需要使用 <code>mapa</code> 指令将本地 SMEM 地址转换为远程可访问地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// PTX: 将本地 smem_addr 映射到目标 CTA 的对应地址</span><br><span class="line">mapa.shared::cluster.u32  remote_addr, smem_addr, dst_cta_rank;</span><br></pre></td></tr></table></figure>

<p><strong>工作原理</strong>：</p>
<ol>
<li>每个 CTA 在 Cluster 内有唯一的 rank（0 到 cluster_size-1）</li>
<li><code>mapa</code> 根据目标 CTA rank 计算出可跨 SM 访问的地址</li>
<li>返回的地址可用于 load&#x2F;store&#x2F;atomic 操作</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CUTLASS 封装：cute/arch/cluster_sm90.hpp:166-177</span></span><br><span class="line"><span class="function">CUTE_DEVICE <span class="type">uint32_t</span> <span class="title">set_block_rank</span><span class="params">(<span class="type">uint32_t</span> smemAddr, <span class="type">uint32_t</span> rank)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CUTE_ARCH_CLUSTER_SM90_ENABLED)</span></span><br><span class="line">  <span class="type">uint32_t</span> result;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;mapa.shared::cluster.u32  %0, %1, %2;\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">              : <span class="string">&quot;=r&quot;</span>(result)</span></span></span><br><span class="line"><span class="params"><span class="function">              : <span class="string">&quot;r&quot;</span>(smemAddr), <span class="string">&quot;r&quot;</span>(rank))</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> smemAddr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-3-跨-SM-的-mbarrier-Arrive"><a href="#1-6-3-跨-SM-的-mbarrier-Arrive" class="headerlink" title="1.6.3 跨 SM 的 mbarrier Arrive"></a>1.6.3 跨 SM 的 mbarrier Arrive</h4><p>当 Cluster 内的一个 CTA 需要 signal 另一个 CTA 的 mbarrier 时，使用 <code>mbarrier.arrive.shared::cluster</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/arch/barrier.h:480-499</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">arrive</span><span class="params">(ValueType <span class="type">const</span>* smem_ptr, <span class="type">uint32_t</span> cta_id, <span class="type">uint32_t</span> pred)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CUDA_BARRIER_ENABLED</span></span><br><span class="line">  <span class="type">uint32_t</span> smem_addr = cute::<span class="built_in">cast_smem_ptr_to_uint</span>(smem_ptr);</span><br><span class="line">  <span class="keyword">if</span> (pred) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;&#123;\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;.reg .b32 remAddr32;\n\t&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;mapa.shared::cluster.u32  remAddr32, %0, %1;\n\t&quot;</span>    <span class="comment">// Step 1: 地址映射</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;mbarrier.arrive.shared::cluster.b64  _, [remAddr32];\n\t&quot;</span>  <span class="comment">// Step 2: 远程 arrive</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;&#125;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : : <span class="string">&quot;r&quot;</span>(smem_addr), <span class="string">&quot;r&quot;</span>(cta_id))</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PTX 指令对比</strong>：</p>
<table>
<thead>
<tr>
<th>操作范围</th>
<th>PTX 指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CTA 内</td>
<td><code>mbarrier.arrive.shared::cta.b64</code></td>
<td>仅本 CTA 线程可见</td>
</tr>
<tr>
<td>Cluster 内</td>
<td><code>mbarrier.arrive.shared::cluster.b64</code></td>
<td>Cluster 内所有 CTA 可见</td>
</tr>
</tbody></table>
<h4 id="1-6-4-Cluster-Barrier-同步流程"><a href="#1-6-4-Cluster-Barrier-同步流程" class="headerlink" title="1.6.4 Cluster Barrier 同步流程"></a>1.6.4 Cluster Barrier 同步流程</h4><pre class="mermaid">sequenceDiagram
    participant CTA0 as CTA 0 (SM 0)
    participant NET as SM-to-SM Network
    participant CTA1 as CTA 1 (SM 1)
    participant CTA2 as CTA 2 (SM 2)
    participant CTA3 as CTA 3 (SM 3)

    Note over CTA0,CTA3: ClusterShape = 2x2, 共 4 个 CTA

    rect rgb(232, 245, 233)
        Note over CTA0: CTA 0 完成计算
        CTA0->>CTA0: mbarrier.arrive.shared::cta (本地)
        CTA0->>NET: mapa + arrive (到 CTA 1)
        NET->>CTA1: arrive signal
        CTA0->>NET: mapa + arrive (到 CTA 2)
        NET->>CTA2: arrive signal
        CTA0->>NET: mapa + arrive (到 CTA 3)
        NET->>CTA3: arrive signal
    end

    rect rgb(227, 242, 253)
        Note over CTA1,CTA3: 其他 CTA 类似操作...
    end

    Note over CTA0,CTA3: 所有 arrive 完成后，barrier phase 翻转</pre>

<h4 id="1-6-5-Cluster-全局同步"><a href="#1-6-5-Cluster-全局同步" class="headerlink" title="1.6.5 Cluster 全局同步"></a>1.6.5 Cluster 全局同步</h4><p>除了 mbarrier 的点对点同步，Hopper 还提供了 Cluster 级别的全局 barrier：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: cute/arch/cluster_sm90.hpp:48-83</span></span><br><span class="line"><span class="function">CUTE_DEVICE <span class="type">void</span> <span class="title">cluster_arrive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;barrier.cluster.arrive.aligned;\n&quot;</span> : : )</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CUTE_DEVICE <span class="type">void</span> <span class="title">cluster_wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;barrier.cluster.wait.aligned;\n&quot;</span> : : )</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CUTE_DEVICE <span class="type">void</span> <span class="title">cluster_sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cluster_arrive</span>();</span><br><span class="line">  <span class="built_in">cluster_wait</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用场景</strong>：</p>
<ul>
<li><code>barrier.cluster</code> 用于 Cluster 内所有 CTA 的全局同步</li>
<li>常用于 barrier 初始化后确保所有 CTA 可见性</li>
<li>与 <code>fence.mbarrier_init.release.cluster</code> 配合使用</li>
</ul>
<h4 id="1-6-6-硬件加速的-Asynchronous-Transaction-Barrier"><a href="#1-6-6-硬件加速的-Asynchronous-Transaction-Barrier" class="headerlink" title="1.6.6 硬件加速的 Asynchronous Transaction Barrier"></a>1.6.6 硬件加速的 Asynchronous Transaction Barrier</h4><p>Hopper 的 mbarrier 支持<strong>硬件加速等待</strong>：</p>
<pre class="mermaid">graph LR
    subgraph Traditional["传统 Barrier (Ampere)"]
        T1[Thread Arrive] --> T2[Spin Wait]
        T2 --> T3[Barrier Complete]
        style T2 fill:#ffcdd2
    end

    subgraph Hopper["Hopper Async Barrier"]
        H1[Thread Arrive] --> H2[Hardware Sleep]
        H2 --> H3[Hardware Wakeup]
        H3 --> H4[Barrier Complete]
        style H2 fill:#c8e6c9
    end</pre>

<p><strong>关键优势</strong>：</p>
<ul>
<li>线程 arrive 后可以 <strong>sleep</strong> 而非 spin，节省能耗</li>
<li>硬件自动唤醒等待线程</li>
<li>与 TMA 操作深度集成，TMA 完成时自动 <code>complete_tx</code></li>
</ul>
<h4 id="1-6-7-性能数据参考"><a href="#1-6-7-性能数据参考" class="headerlink" title="1.6.7 性能数据参考"></a>1.6.7 性能数据参考</h4><table>
<thead>
<tr>
<th>指标</th>
<th>数值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>本地 SMEM 访问</td>
<td>~29 cycles</td>
<td>基准延迟</td>
</tr>
<tr>
<td>DSMEM 本地访问</td>
<td>~33 cycles</td>
<td>轻微额外开销</td>
</tr>
<tr>
<td>跨 SM DSMEM 访问</td>
<td>~181 cycles</td>
<td>2-block cluster</td>
</tr>
<tr>
<td>经过 L2 访问</td>
<td>~956 cycles</td>
<td>传统路径</td>
</tr>
<tr>
<td>DSMEM 带宽 (2-block)</td>
<td>~3.27 TB&#x2F;s</td>
<td>峰值吞吐</td>
</tr>
<tr>
<td>DSMEM 带宽 (4-block)</td>
<td>~2.65 TB&#x2F;s</td>
<td>带宽竞争</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意</strong>：随着 Cluster size 增大，SM 间带宽竞争加剧，吞吐量会下降。</p>
</blockquote>
<h4 id="1-6-8-参考资料"><a href="#1-6-8-参考资料" class="headerlink" title="1.6.8 参考资料"></a>1.6.8 参考资料</h4><ul>
<li><a target="_blank" rel="noopener" href="https://developer.nvidia.com/blog/nvidia-hopper-architecture-in-depth/">NVIDIA Hopper Architecture In-Depth</a></li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/html/2501.12084v1">Dissecting the NVIDIA Hopper Architecture through Microbenchmarking</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/hopper-tuning-guide/index.html">Hopper Tuning Guide</a></li>
<li><a target="_blank" rel="noopener" href="https://research.colfax-intl.com/tutorial-hopper-tma/">CUTLASS Tutorial: Mastering the TMA</a></li>
</ul>
<hr>
<h2 id="2-PipelineState-详解"><a href="#2-PipelineState-详解" class="headerlink" title="2. PipelineState 详解"></a>2. PipelineState 详解</h2><p><code>PipelineState</code> 是 Pipeline 的状态追踪器，管理循环缓冲区中的当前位置。</p>
<h3 id="2-1-数据结构定义"><a href="#2-1-数据结构定义" class="headerlink" title="2.1 数据结构定义"></a>2.1 数据结构定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:170-250</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">uint32_t</span> Stages_&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PipelineState</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint32_t</span> Stages = Stages_;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> index_ = <span class="number">0</span>;        <span class="comment">// 当前 stage 索引 (0 到 Stages-1)</span></span><br><span class="line">  <span class="type">uint32_t</span> phase_ = <span class="number">0</span>;   <span class="comment">// 当前 phase (0 或 1)，每绕回一次翻转</span></span><br><span class="line">  <span class="type">uint32_t</span> count_ = <span class="number">0</span>;   <span class="comment">// 总迭代次数</span></span><br><span class="line"></span><br><span class="line">  <span class="function">CUTLASS_DEVICE</span></span><br><span class="line"><span class="function">  <span class="title">PipelineState</span><span class="params">()</span>: index_&#123;</span>&#125;, phase_&#123;&#125;, count_&#123;&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">CUTLASS_DEVICE</span></span><br><span class="line"><span class="function">  <span class="title">PipelineState</span><span class="params">(<span class="type">int</span> index, <span class="type">uint32_t</span> phase, <span class="type">uint32_t</span> count)</span></span></span><br><span class="line"><span class="function">    : index_(index)</span></span><br><span class="line"><span class="function">    , phase_(phase)</span></span><br><span class="line"><span class="function">    , count_(count) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-成员变量说明"><a href="#2-2-成员变量说明" class="headerlink" title="2.2 成员变量说明"></a>2.2 成员变量说明</h3><table>
<thead>
<tr>
<th>成员</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>index_</code></td>
<td>int</td>
<td>当前 stage 在循环缓冲区中的索引，范围 [0, Stages-1]</td>
</tr>
<tr>
<td><code>phase_</code></td>
<td>uint32_t</td>
<td>当前 phase 值，0 或 1，用于 barrier 同步</td>
</tr>
<tr>
<td><code>count_</code></td>
<td>uint32_t</td>
<td>总迭代计数，用于追踪已处理多少次</td>
</tr>
</tbody></table>
<h3 id="2-3-自增操作符"><a href="#2-3-自增操作符" class="headerlink" title="2.3 自增操作符"></a>2.3 自增操作符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:203-213</span></span><br><span class="line">CUTLASS_DEVICE</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>++() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(Stages &gt; <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    ++index_;</span><br><span class="line">    ++count_;</span><br><span class="line">    <span class="keyword">if</span> (index_ == Stages) &#123;</span><br><span class="line">      index_ = <span class="number">0</span>;        <span class="comment">// 回绕到开头</span></span><br><span class="line">      phase_ ^= <span class="number">1</span>;       <span class="comment">// 翻转 phase</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：当 <code>index_</code> 从 <code>Stages-1</code> 回绕到 <code>0</code> 时，<code>phase_</code> 翻转。这确保了 barrier 能区分不同轮次的操作。</p>
<pre class="mermaid">stateDiagram-v2
    direction LR

    state "Stage 0" as S0
    state "Stage 1" as S1
    state "Stage 2" as S2
    state "Stage 3" as S3

    [*] --> S0: index=0, phase=0
    S0 --> S1: ++index
    S1 --> S2: ++index
    S2 --> S3: ++index
    S3 --> S0: index回绕, phase翻转

    note right of S3
        当 index == Stages 时:
        index = 0
        phase ^= 1
    end note</pre>

<h3 id="2-4-advance-方法"><a href="#2-4-advance-方法" class="headerlink" title="2.4 advance 方法"></a>2.4 advance 方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:228-244</span></span><br><span class="line"><span class="function">CUTLASS_DEVICE</span></span><br><span class="line"><span class="function">PipelineState&amp; <span class="title">advance</span><span class="params">(<span class="type">uint32_t</span> num_iterations)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(Stages &gt; <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否需要翻转 phase</span></span><br><span class="line">    <span class="keyword">if</span> ((num_iterations &lt; Stages) &amp;&amp; (index_ + num_iterations) &gt;= Stages ) &#123;</span><br><span class="line">      phase_ ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((num_iterations &gt;= Stages) &amp;&amp; (((index_ + num_iterations) / Stages) % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">      phase_ ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index_ = (index_ + num_iterations) % Stages;</span><br><span class="line">    count_ += num_iterations;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-访问器方法"><a href="#2-5-访问器方法" class="headerlink" title="2.5 访问器方法"></a>2.5 访问器方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CUTLASS_DEVICE <span class="type">int</span> <span class="title">index</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> index_; &#125;</span><br><span class="line"><span class="function">CUTLASS_DEVICE <span class="type">uint32_t</span> <span class="title">phase</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> phase_; &#125;</span><br><span class="line"><span class="function">CUTLASS_DEVICE <span class="type">uint32_t</span> <span class="title">count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> count_; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-Producer-起始状态"><a href="#2-6-Producer-起始状态" class="headerlink" title="2.6 Producer 起始状态"></a>2.6 Producer 起始状态</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:252-260</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Pipeline&gt;</span></span><br><span class="line"><span class="function">CUTLASS_DEVICE</span></span><br><span class="line"><span class="function">PipelineState&lt;Pipeline::Stages&gt; <span class="title">make_producer_start_state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Producer 以相反的 phase 开始，因为缓冲区初始为空</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">int</span> InitialProducerStage = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">uint32_t</span> InitialProducerPhase = <span class="number">1</span>;  <span class="comment">// 注意：phase 为 1</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">uint32_t</span> InitialProducerCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;InitialProducerStage, InitialProducerPhase, InitialProducerCount&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重要</strong>：Producer 初始 phase 为 1，而 Consumer 初始 phase 为 0。这是因为缓冲区一开始是空的，Producer 需要先填充数据。</p>
<hr>
<h2 id="3-PipelineTmaAsync-详解"><a href="#3-PipelineTmaAsync-详解" class="headerlink" title="3. PipelineTmaAsync 详解"></a>3. PipelineTmaAsync 详解</h2><p><code>PipelineTmaAsync</code> 是 SM90 上用于 TMA 异步加载的 Pipeline 类，实现了生产者-消费者同步模式。</p>
<p>源码位置：<a target="_blank" rel="noopener" href="https://github.com/NVIDIA/cutlass/blob/main/include/cutlass/pipeline/sm90_pipeline.hpp">sm90_pipeline.hpp</a></p>
<h3 id="3-1-类型定义"><a href="#3-1-类型定义" class="headerlink" title="3.1 类型定义"></a>3.1 类型定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:270-278</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> Stages_&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PipelineTmaAsync</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> FullBarrier = cutlass::arch::ClusterTransactionBarrier;</span><br><span class="line">  <span class="keyword">using</span> EmptyBarrier = cutlass::arch::ClusterBarrier;</span><br><span class="line">  <span class="keyword">using</span> ProducerBarrierType = FullBarrier::ValueType;   <span class="comment">// uint64_t</span></span><br><span class="line">  <span class="keyword">using</span> ConsumerBarrierType = EmptyBarrier::ValueType;  <span class="comment">// uint64_t</span></span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint32_t</span> Stages = Stages_;</span><br><span class="line">  <span class="keyword">using</span> PipelineState = cutlass::PipelineState&lt;Stages&gt;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>类型别名</th>
<th>实际类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>FullBarrier</code></td>
<td><code>ClusterTransactionBarrier</code></td>
<td>数据就绪信号，支持事务计数</td>
</tr>
<tr>
<td><code>EmptyBarrier</code></td>
<td><code>ClusterBarrier</code></td>
<td>空间释放信号，纯到达计数</td>
</tr>
<tr>
<td><code>ProducerBarrierType</code></td>
<td><code>uint64_t</code></td>
<td>Full barrier 的原始值类型</td>
</tr>
<tr>
<td><code>ConsumerBarrierType</code></td>
<td><code>uint64_t</code></td>
<td>Empty barrier 的原始值类型</td>
</tr>
</tbody></table>
<h3 id="3-2-SharedStorage-结构"><a href="#3-2-SharedStorage-结构" class="headerlink" title="3.2 SharedStorage 结构"></a>3.2 SharedStorage 结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:280-283</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SharedStorage</span> &#123;</span><br><span class="line">  FullBarrier full_barrier_[Stages];   <span class="comment">// 每个 stage 一个 full barrier</span></span><br><span class="line">  EmptyBarrier empty_barrier_[Stages]; <span class="comment">// 每个 stage 一个 empty barrier</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个 Pipeline stage 都有一对 barrier：</p>
<ul>
<li><strong>full_barrier_</strong>：Producer 填充数据后 signal，Consumer 等待</li>
<li><strong>empty_barrier_</strong>：Consumer 使用完毕后 signal，Producer 等待</li>
</ul>
<pre class="mermaid">graph TB
    subgraph "SharedStorage (SMEM)"
        subgraph "Stage 0"
            FB0[full_barrier_0]
            EB0[empty_barrier_0]
        end
        subgraph "Stage 1"
            FB1[full_barrier_1]
            EB1[empty_barrier_1]
        end
        subgraph "Stage 2"
            FB2[full_barrier_2]
            EB2[empty_barrier_2]
        end
        subgraph "Stage N-1"
            FBN[full_barrier_N-1]
            EBN[empty_barrier_N-1]
        end
    end

    FULL[full_barrier_ptr_] --> FB0
    EMPTY[empty_barrier_ptr_] --> EB0

    style FB0 fill:#e3f2fd
    style FB1 fill:#e3f2fd
    style FB2 fill:#e3f2fd
    style FBN fill:#e3f2fd
    style EB0 fill:#fff8e1
    style EB1 fill:#fff8e1
    style EB2 fill:#fff8e1
    style EBN fill:#fff8e1</pre>

<h3 id="3-3-ThreadCategory-枚举"><a href="#3-3-ThreadCategory-枚举" class="headerlink" title="3.3 ThreadCategory 枚举"></a>3.3 ThreadCategory 枚举</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:285-290</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ThreadCategory</span> &#123;</span><br><span class="line">  NonParticipant,    <span class="comment">// 不参与 Pipeline 操作</span></span><br><span class="line">  Producer,          <span class="comment">// 仅作为生产者</span></span><br><span class="line">  Consumer,          <span class="comment">// 仅作为消费者</span></span><br><span class="line">  ProducerConsumer   <span class="comment">// 同时是生产者和消费者</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-Params-参数结构"><a href="#3-4-Params-参数结构" class="headerlink" title="3.4 Params 参数结构"></a>3.4 Params 参数结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:292-299</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Params</span> &#123;</span><br><span class="line">  <span class="type">uint32_t</span> transaction_bytes = <span class="number">0</span>;    <span class="comment">// 每次 TMA 传输的字节数</span></span><br><span class="line">  ThreadCategory role = ThreadCategory::NonParticipant;  <span class="comment">// 线程角色</span></span><br><span class="line">  <span class="type">uint32_t</span> is_leader = <span class="number">0</span>;            <span class="comment">// 是否为 leader 线程（负责 barrier 操作）</span></span><br><span class="line">  <span class="type">uint32_t</span> num_consumers = <span class="number">0</span>;        <span class="comment">// Consumer 线程总数</span></span><br><span class="line">  <span class="type">uint32_t</span> num_producers = <span class="number">1</span>;        <span class="comment">// Producer 线程总数</span></span><br><span class="line">  <span class="type">int</span> initializing_warp = <span class="number">0</span>;         <span class="comment">// 负责初始化 barrier 的 warp</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-私有成员变量"><a href="#3-5-私有成员变量" class="headerlink" title="3.5 私有成员变量"></a>3.5 私有成员变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:494-499</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">uint32_t</span> dst_blockid_ = <span class="number">0</span>;              <span class="comment">// 目标 CTA ID（用于 cluster 内通信）</span></span><br><span class="line">  <span class="type">uint32_t</span> is_signaling_thread_ = <span class="number">0</span>;      <span class="comment">// 是否负责发送 arrive 信号</span></span><br><span class="line">  FullBarrier *full_barrier_ptr_ = <span class="literal">nullptr</span>;   <span class="comment">// 指向 full barrier 数组</span></span><br><span class="line">  EmptyBarrier *empty_barrier_ptr_ = <span class="literal">nullptr</span>; <span class="comment">// 指向 empty barrier 数组</span></span><br><span class="line">  Params params_;                         <span class="comment">// 配置参数</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>成员</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>dst_blockid_</code></td>
<td>在 cluster 模式下，标识要发送 arrive 信号的目标 CTA</td>
</tr>
<tr>
<td><code>is_signaling_thread_</code></td>
<td>标记此线程是否负责发送 arrive 信号（避免重复发送）</td>
</tr>
<tr>
<td><code>full_barrier_ptr_</code></td>
<td>指向共享内存中 FullBarrier 数组的指针</td>
</tr>
<tr>
<td><code>empty_barrier_ptr_</code></td>
<td>指向共享内存中 EmptyBarrier 数组的指针</td>
</tr>
<tr>
<td><code>params_</code></td>
<td>保存构造时传入的配置参数</td>
</tr>
</tbody></table>
<h3 id="3-6-构造函数"><a href="#3-6-构造函数" class="headerlink" title="3.6 构造函数"></a>3.6 构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:326-377</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ClusterShape, <span class="keyword">class</span> InitBarriers, <span class="keyword">class</span> InitMasks&gt;</span></span><br><span class="line"><span class="function">CUTLASS_DEVICE</span></span><br><span class="line"><span class="function"><span class="title">PipelineTmaAsync</span><span class="params">(SharedStorage&amp; storage, Params params, ClusterShape cluster_shape,</span></span></span><br><span class="line"><span class="params"><span class="function">                 InitBarriers = &#123;&#125;, InitMasks = &#123;&#125;)</span></span></span><br><span class="line"><span class="function">    : params_(params)</span></span><br><span class="line"><span class="function">    , full_barrier_ptr_(&amp;storage.full_barrier_[<span class="number">0</span>])</span></span><br><span class="line"><span class="function">    , empty_barrier_ptr_(&amp;storage.empty_barrier_[<span class="number">0</span>]) &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> warp_idx = <span class="built_in">canonical_warp_idx_sync</span>();</span><br><span class="line">  <span class="type">int</span> thread_idx = threadIdx.x;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 barrier（如果需要）</span></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(cute::is_same_v&lt;InitBarriers, cute::true_type&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init_barriers</span>(storage, params_, cluster_shape);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化信号掩码（用于 cluster 内通信）</span></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(cute::is_same_v&lt;InitMasks, cute::true_type&gt;)</span> </span>&#123;</span><br><span class="line">    dim3 block_id = cute::<span class="built_in">block_id_in_cluster</span>();</span><br><span class="line">    <span class="keyword">auto</span> cluster_size = cute::<span class="built_in">size</span>(cluster_shape);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cluster_size == <span class="number">1</span>) &#123;</span><br><span class="line">      is_signaling_thread_ = <span class="literal">true</span>;</span><br><span class="line">      dst_blockid_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在 warp group 内分配 arrive 职责</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-Barrier-初始化"><a href="#3-7-Barrier-初始化" class="headerlink" title="3.7 Barrier 初始化"></a>3.7 Barrier 初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:301-324</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ClusterShape</span>&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> CUTLASS_DEVICE <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">init_barriers</span><span class="params">(SharedStorage&amp; storage, Params params, ClusterShape cluster_shape)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> warp_idx = <span class="built_in">canonical_warp_idx_sync</span>();</span><br><span class="line">  <span class="type">bool</span> is_initializing_warp = (warp_idx == params.initializing_warp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_initializing_warp) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> <span class="type">const</span> producer_arv_cnt = params.num_producers;</span><br><span class="line">    <span class="type">uint32_t</span> multicast_consumer_arrival_count = params.num_consumers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cluster 模式下调整 arrival count</span></span><br><span class="line">    <span class="keyword">if</span> (cute::<span class="built_in">size</span>(cluster_shape) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="type">uint32_t</span> <span class="type">const</span> num_consumer_warpgroups_per_cluster =</span><br><span class="line">          cute::<span class="built_in">ceil_div</span>(params.num_consumers, NumThreadsPerWarpGroup);</span><br><span class="line">      multicast_consumer_arrival_count =</span><br><span class="line">          (cute::<span class="built_in">size</span>&lt;<span class="number">0</span>&gt;(cluster_shape) + cute::<span class="built_in">size</span>&lt;<span class="number">1</span>&gt;(cluster_shape) - <span class="number">1</span>) *</span><br><span class="line">          num_consumer_warpgroups_per_cluster;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 barrier 对</span></span><br><span class="line">    <span class="built_in">initialize_barrier_array_pair_aligned</span>(...);</span><br><span class="line">  &#125;</span><br><span class="line">  cutlass::arch::<span class="built_in">fence_barrier_init</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-Producer-API-详解"><a href="#4-Producer-API-详解" class="headerlink" title="4. Producer API 详解"></a>4. Producer API 详解</h2><h3 id="4-1-producer-try-acquire"><a href="#4-1-producer-try-acquire" class="headerlink" title="4.1 producer_try_acquire"></a>4.1 producer_try_acquire</h3><p>非阻塞尝试获取缓冲区空间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:419-422 (public)</span></span><br><span class="line"><span class="function">CUTLASS_DEVICE</span></span><br><span class="line"><span class="function">ProducerToken <span class="title">producer_try_acquire</span><span class="params">(PipelineState state, <span class="type">uint32_t</span> skip_wait = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">producer_try_acquire</span>(state.<span class="built_in">index</span>(), state.<span class="built_in">phase</span>(), skip_wait);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:501-509 (private)</span></span><br><span class="line"><span class="function">CUTLASS_DEVICE</span></span><br><span class="line"><span class="function">ProducerToken <span class="title">producer_try_acquire</span><span class="params">(<span class="type">uint32_t</span> stage, <span class="type">uint32_t</span> phase, <span class="type">uint32_t</span> skip_wait)</span> </span>&#123;</span><br><span class="line">  detail::<span class="built_in">pipeline_check_is_producer</span>(params_.role);</span><br><span class="line">  <span class="keyword">if</span> (skip_wait) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;BarrierStatus::WaitDone&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> barrier_status = empty_barrier_ptr_[stage].<span class="built_in">try_wait</span>(phase);</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="built_in">static_cast</span>&lt;BarrierStatus&gt;(barrier_status)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PTX 指令</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mbarrier.try_wait.parity.shared::cta.b64 P1, [smem_addr], phase;</span><br><span class="line">selp.b32 result, 1, 0, P1;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-producer-acquire"><a href="#4-2-producer-acquire" class="headerlink" title="4.2 producer_acquire"></a>4.2 producer_acquire</h3><p>阻塞等待缓冲区空间，并设置期望传输字节数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:424-427 (public)</span></span><br><span class="line"><span class="function">CUTLASS_DEVICE</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer_acquire</span><span class="params">(PipelineState state)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">producer_acquire</span>(state.<span class="built_in">index</span>(), state.<span class="built_in">phase</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:511-528 (private)</span></span><br><span class="line"><span class="function">CUTLASS_DEVICE</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer_acquire</span><span class="params">(<span class="type">uint32_t</span> stage, <span class="type">uint32_t</span> phase)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Step 1: 等待 Consumer 释放空间</span></span><br><span class="line">  empty_barrier_ptr_[stage].<span class="built_in">wait</span>(phase);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 2: Leader 线程设置期望传输字节数</span></span><br><span class="line">  <span class="keyword">if</span> (params_.is_leader) &#123;</span><br><span class="line">    full_barrier_ptr_[stage].<span class="built_in">arrive_and_expect_tx</span>(params_.transaction_bytes);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PTX 指令</strong>：</p>
<p>等待部分（spin loop）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LAB_WAIT:</span><br><span class="line">    mbarrier.try_wait.parity.shared::cta.b64 P1, [smem_addr], phase, 0x989680;</span><br><span class="line">    @P1 bra DONE;</span><br><span class="line">    bra LAB_WAIT;</span><br><span class="line">DONE:</span><br></pre></td></tr></table></figure>

<p>设置期望字节数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbarrier.arrive.expect_tx.shared::cta.b64 _, [smem_addr], transaction_bytes;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-producer-acquire-带-token"><a href="#4-3-producer-acquire-带-token" class="headerlink" title="4.3 producer_acquire (带 token)"></a>4.3 producer_acquire (带 token)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:530-550</span></span><br><span class="line"><span class="function">CUTLASS_DEVICE</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer_acquire</span><span class="params">(<span class="type">uint32_t</span> stage, <span class="type">uint32_t</span> phase, ProducerToken barrier_token)</span> </span>&#123;</span><br><span class="line">  detail::<span class="built_in">pipeline_check_is_producer</span>(params_.role);</span><br><span class="line">  <span class="comment">// 如果 try_acquire 已经成功，跳过等待</span></span><br><span class="line">  <span class="keyword">if</span> (barrier_token != BarrierStatus::WaitDone) &#123;</span><br><span class="line">    empty_barrier_ptr_[stage].<span class="built_in">wait</span>(phase);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (params_.is_leader) &#123;</span><br><span class="line">    full_barrier_ptr_[stage].<span class="built_in">arrive_and_expect_tx</span>(params_.transaction_bytes);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-producer-expect-transaction"><a href="#4-4-producer-expect-transaction" class="headerlink" title="4.4 producer_expect_transaction"></a>4.4 producer_expect_transaction</h3><p>额外增加期望传输字节数（用于多次 TMA 操作）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:552-558</span></span><br><span class="line"><span class="function">CUTLASS_DEVICE</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer_expect_transaction</span><span class="params">(<span class="type">uint32_t</span> stage, <span class="type">uint32_t</span> transaction_bytes)</span> </span>&#123;</span><br><span class="line">  detail::<span class="built_in">pipeline_check_is_producer</span>(params_.role);</span><br><span class="line">  <span class="keyword">if</span> (params_.is_leader) &#123;</span><br><span class="line">    full_barrier_ptr_[stage].<span class="built_in">expect_transaction</span>(transaction_bytes);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PTX 指令</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbarrier.expect_tx.shared::cta.b64 [smem_addr], transaction_bytes;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-producer-commit"><a href="#4-5-producer-commit" class="headerlink" title="4.5 producer_commit"></a>4.5 producer_commit</h3><p>TMA 完成后由硬件自动触发：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:560-587</span></span><br><span class="line"><span class="function">CUTLASS_DEVICE</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer_commit</span><span class="params">(<span class="type">uint32_t</span> stage, <span class="type">uint32_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 仅用于单元测试（无 TMA 时手动提交）</span></span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> CUTLASS_UNIT_TEST_PIPELINE</span></span><br><span class="line">    <span class="keyword">if</span> (params_.is_leader) &#123;</span><br><span class="line">      full_barrier_ptr_[stage].<span class="built_in">complete_transaction</span>(bytes);</span><br><span class="line">      <span class="comment">// Cluster 模式下通知其他 CTA...</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PTX 指令</strong>（TMA 硬件自动执行）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbarrier.complete_tx.shared::cluster.relaxed.cluster.b64 [smem_addr], transaction_bytes;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-producer-get-barrier"><a href="#4-6-producer-get-barrier" class="headerlink" title="4.6 producer_get_barrier"></a>4.6 producer_get_barrier</h3><p>返回 barrier 指针供 TMA 使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:638-641</span></span><br><span class="line"><span class="function">CUTLASS_DEVICE</span></span><br><span class="line"><span class="function">ProducerBarrierType* <span class="title">producer_get_barrier</span><span class="params">(<span class="type">uint32_t</span> stage)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;ProducerBarrierType*&gt;(&amp;full_barrier_ptr_[stage]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-7-producer-tail"><a href="#4-7-producer-tail" class="headerlink" title="4.7 producer_tail"></a>4.7 producer_tail</h3><p>防止 Producer block 过早退出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:447-454</span></span><br><span class="line"><span class="function">CUTLASS_DEVICE</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer_tail</span><span class="params">(PipelineState state)</span> </span>&#123;</span><br><span class="line">  detail::<span class="built_in">pipeline_check_is_producer</span>(params_.role);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> count = <span class="number">0</span>; count &lt; Stages; ++count) &#123;</span><br><span class="line">    empty_barrier_ptr_[state.<span class="built_in">index</span>()].<span class="built_in">wait</span>(state.<span class="built_in">phase</span>());</span><br><span class="line">    ++state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-Consumer-API-详解"><a href="#5-Consumer-API-详解" class="headerlink" title="5. Consumer API 详解"></a>5. Consumer API 详解</h2><h3 id="5-1-consumer-try-wait"><a href="#5-1-consumer-try-wait" class="headerlink" title="5.1 consumer_try_wait"></a>5.1 consumer_try_wait</h3><p>非阻塞尝试等待数据就绪：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:590-597</span></span><br><span class="line"><span class="function">CUTLASS_DEVICE</span></span><br><span class="line"><span class="function">ConsumerToken <span class="title">consumer_try_wait</span><span class="params">(<span class="type">uint32_t</span> stage, <span class="type">uint32_t</span> phase, <span class="type">uint32_t</span> skip_wait)</span> </span>&#123;</span><br><span class="line">  detail::<span class="built_in">pipeline_check_is_consumer</span>(params_.role);</span><br><span class="line">  <span class="keyword">if</span> (skip_wait) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;BarrierStatus::WaitDone&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> barrier_status = full_barrier_ptr_[stage].<span class="built_in">try_wait</span>(phase);</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="built_in">static_cast</span>&lt;BarrierStatus&gt;(barrier_status)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<ul>
<li><code>BarrierStatus::WaitDone</code> (1)：数据已就绪</li>
<li><code>BarrierStatus::WaitAgain</code> (0)：数据未就绪</li>
</ul>
<h3 id="5-2-consumer-test-wait"><a href="#5-2-consumer-test-wait" class="headerlink" title="5.2 consumer_test_wait"></a>5.2 consumer_test_wait</h3><p>与 try_wait 类似，但使用 <code>test_wait</code> PTX 指令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:599-607</span></span><br><span class="line"><span class="function">CUTLASS_DEVICE</span></span><br><span class="line"><span class="function">ConsumerToken <span class="title">consumer_test_wait</span><span class="params">(<span class="type">uint32_t</span> stage, <span class="type">uint32_t</span> phase, <span class="type">uint32_t</span> skip_wait)</span> </span>&#123;</span><br><span class="line">  detail::<span class="built_in">pipeline_check_is_consumer</span>(params_.role);</span><br><span class="line">  <span class="keyword">if</span> (skip_wait) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;BarrierStatus::WaitDone&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> barrier_status = full_barrier_ptr_[stage].<span class="built_in">test_wait</span>(phase);</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="built_in">static_cast</span>&lt;BarrierStatus&gt;(barrier_status)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-consumer-wait"><a href="#5-3-consumer-wait" class="headerlink" title="5.3 consumer_wait"></a>5.3 consumer_wait</h3><p>阻塞等待数据就绪：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:609-623</span></span><br><span class="line"><span class="function">CUTLASS_DEVICE</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer_wait</span><span class="params">(<span class="type">uint32_t</span> stage, <span class="type">uint32_t</span> phase)</span> </span>&#123;</span><br><span class="line">  detail::<span class="built_in">pipeline_check_is_consumer</span>(params_.role);</span><br><span class="line">  full_barrier_ptr_[stage].<span class="built_in">wait</span>(phase);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带 token 版本</span></span><br><span class="line"><span class="function">CUTLASS_DEVICE</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer_wait</span><span class="params">(<span class="type">uint32_t</span> stage, <span class="type">uint32_t</span> phase, ConsumerToken barrier_token)</span> </span>&#123;</span><br><span class="line">  detail::<span class="built_in">pipeline_check_is_consumer</span>(params_.role);</span><br><span class="line">  <span class="keyword">if</span> (barrier_token == BarrierStatus::WaitAgain) &#123;</span><br><span class="line">    full_barrier_ptr_[stage].<span class="built_in">wait</span>(phase);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果已经 WaitDone，直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-consumer-release"><a href="#5-4-consumer-release" class="headerlink" title="5.4 consumer_release"></a>5.4 consumer_release</h3><p>通知 Producer 空间已释放：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/pipeline/sm90_pipeline.hpp:625-636</span></span><br><span class="line"><span class="function">CUTLASS_DEVICE</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer_release</span><span class="params">(<span class="type">uint32_t</span> stage, <span class="type">uint32_t</span> skip = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  detail::<span class="built_in">pipeline_check_is_consumer</span>(params_.role);</span><br><span class="line">  empty_barrier_ptr_[stage].<span class="built_in">arrive</span>(dst_blockid_, is_signaling_thread_ &amp; (!skip));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PTX 指令</strong>：</p>
<p>本地 CTA arrive：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbarrier.arrive.shared::cta.b64 _, [smem_addr];</span><br></pre></td></tr></table></figure>

<p>远程 Cluster arrive：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapa.shared::cluster.u32 remAddr32, smem_addr, cta_id;</span><br><span class="line">mbarrier.arrive.shared::cluster.b64 _, [remAddr32];</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-Pipeline-API-到-PTX-映射总览"><a href="#6-Pipeline-API-到-PTX-映射总览" class="headerlink" title="6. Pipeline API 到 PTX 映射总览"></a>6. Pipeline API 到 PTX 映射总览</h2><table>
<thead>
<tr>
<th>Pipeline API</th>
<th>Barrier 类型</th>
<th>PTX 指令</th>
</tr>
</thead>
<tbody><tr>
<td><code>producer_try_acquire</code></td>
<td>EmptyBarrier</td>
<td><code>mbarrier.try_wait.parity</code> (单次)</td>
</tr>
<tr>
<td><code>producer_acquire</code> (wait)</td>
<td>EmptyBarrier</td>
<td><code>mbarrier.try_wait.parity</code> (spin)</td>
</tr>
<tr>
<td><code>producer_acquire</code> (leader)</td>
<td>FullBarrier</td>
<td><code>mbarrier.arrive.expect_tx</code></td>
</tr>
<tr>
<td><code>producer_expect_transaction</code></td>
<td>FullBarrier</td>
<td><code>mbarrier.expect_tx</code></td>
</tr>
<tr>
<td><code>producer_commit</code></td>
<td>FullBarrier</td>
<td><code>mbarrier.complete_tx</code> (TMA 自动)</td>
</tr>
<tr>
<td><code>consumer_try_wait</code></td>
<td>FullBarrier</td>
<td><code>mbarrier.try_wait.parity</code> (单次)</td>
</tr>
<tr>
<td><code>consumer_test_wait</code></td>
<td>FullBarrier</td>
<td><code>mbarrier.test_wait.parity</code></td>
</tr>
<tr>
<td><code>consumer_wait</code></td>
<td>FullBarrier</td>
<td><code>mbarrier.try_wait.parity</code> (spin)</td>
</tr>
<tr>
<td><code>consumer_release</code></td>
<td>EmptyBarrier</td>
<td><code>mbarrier.arrive</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="7-ClusterBarrier-实现"><a href="#7-ClusterBarrier-实现" class="headerlink" title="7. ClusterBarrier 实现"></a>7. ClusterBarrier 实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/arch/barrier.h:341-532</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ClusterBarrier</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> ValueType = <span class="type">uint64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  ValueType barrier_;  <span class="comment">// SMEM 中的 64-bit mbarrier 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 初始化 barrier</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init</span><span class="params">(ValueType <span class="type">const</span>* smem_ptr, <span class="type">uint32_t</span> arrive_count)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> smem_addr = cute::<span class="built_in">cast_smem_ptr_to_uint</span>(smem_ptr);</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;mbarrier.init.shared::cta.b64 [%1], %0;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : : <span class="string">&quot;r&quot;</span>(arrive_count), <span class="string">&quot;r&quot;</span>(smem_addr))</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻塞等待（spin loop）</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">wait</span><span class="params">(ValueType <span class="type">const</span>* smem_ptr, <span class="type">uint32_t</span> phase)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> smem_addr = cute::<span class="built_in">cast_smem_ptr_to_uint</span>(smem_ptr);</span><br><span class="line">    <span class="type">uint32_t</span> ticks = <span class="number">0x989680</span>;  <span class="comment">// ~10M cycles 超时后重试</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;.reg .pred P1;\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;LAB_WAIT:\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;mbarrier.try_wait.parity.shared::cta.b64 P1, [%0], %1, %2;\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;@P1 bra DONE;\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;bra LAB_WAIT;\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;DONE:&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : : <span class="string">&quot;r&quot;</span>(smem_addr), <span class="string">&quot;r&quot;</span>(phase), <span class="string">&quot;r&quot;</span>(ticks))</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非阻塞尝试等待</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">try_wait</span><span class="params">(ValueType <span class="type">const</span>* smem_ptr, <span class="type">uint32_t</span> phase)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> smem_addr = cute::<span class="built_in">cast_smem_ptr_to_uint</span>(smem_ptr);</span><br><span class="line">    <span class="type">uint32_t</span> waitComplete;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;.reg .pred P1;\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;mbarrier.try_wait.parity.shared::cta.b64 P1, [%1], %2;\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;selp.b32 %0, 1, 0, P1;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : <span class="string">&quot;=r&quot;</span>(waitComplete) : <span class="string">&quot;r&quot;</span>(smem_addr), <span class="string">&quot;r&quot;</span>(phase))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(waitComplete);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本地 arrive</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">arrive</span><span class="params">(ValueType <span class="type">const</span>* smem_ptr)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> smem_addr = cute::<span class="built_in">cast_smem_ptr_to_uint</span>(smem_ptr);</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;mbarrier.arrive.shared::cta.b64 _, [%0];&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : : <span class="string">&quot;r&quot;</span>(smem_addr))</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 远程 cluster arrive</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">arrive</span><span class="params">(ValueType <span class="type">const</span>* smem_ptr, <span class="type">uint32_t</span> cta_id, <span class="type">uint32_t</span> pred)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> smem_addr = cute::<span class="built_in">cast_smem_ptr_to_uint</span>(smem_ptr);</span><br><span class="line">    <span class="keyword">if</span> (pred) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="string">&quot;.reg .b32 remAddr32;\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="string">&quot;mapa.shared::cluster.u32 remAddr32, %0, %1;\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="string">&quot;mbarrier.arrive.shared::cluster.b64 _, [remAddr32];&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">          : : <span class="string">&quot;r&quot;</span>(smem_addr), <span class="string">&quot;r&quot;</span>(cta_id))</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-ClusterTransactionBarrier-实现"><a href="#8-ClusterTransactionBarrier-实现" class="headerlink" title="8. ClusterTransactionBarrier 实现"></a>8. ClusterTransactionBarrier 实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码: include/cutlass/arch/barrier.h:538-693</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ClusterTransactionBarrier</span> : <span class="keyword">public</span> ClusterBarrier &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Arrive + 设置期望传输字节数</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">arrive_and_expect_tx</span><span class="params">(ValueType <span class="type">const</span>* smem_ptr, <span class="type">uint32_t</span> transaction_bytes)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> smem_addr = cute::<span class="built_in">cast_smem_ptr_to_uint</span>(smem_ptr);</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;mbarrier.arrive.expect_tx.shared::cta.b64 _, [%1], %0;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : : <span class="string">&quot;r&quot;</span>(transaction_bytes), <span class="string">&quot;r&quot;</span>(smem_addr))</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 仅设置期望字节数（不 arrive）</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">expect_transaction</span><span class="params">(ValueType <span class="type">const</span>* smem_ptr, <span class="type">uint32_t</span> transaction_bytes)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> smem_addr = cute::<span class="built_in">cast_smem_ptr_to_uint</span>(smem_ptr);</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;mbarrier.expect_tx.shared::cta.b64 [%1], %0;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : : <span class="string">&quot;r&quot;</span>(transaction_bytes), <span class="string">&quot;r&quot;</span>(smem_addr))</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成传输（减少 pending 字节数）- TMA 硬件自动调用</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">complete_transaction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ValueType <span class="type">const</span>* smem_ptr, <span class="type">uint32_t</span> dst_cta_id,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">uint32_t</span> transaction_bytes, <span class="type">uint32_t</span> pred = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> smem_addr = cute::<span class="built_in">cast_smem_ptr_to_uint</span>(smem_ptr);</span><br><span class="line">    smem_addr = cute::<span class="built_in">set_block_rank</span>(smem_addr, dst_cta_id);</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;.reg .pred p;\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;setp.eq.u32 p, %2, 1;\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;@p mbarrier.complete_tx.shared::cluster.relaxed.cluster.b64 [%1], %0;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : : <span class="string">&quot;r&quot;</span>(transaction_bytes), <span class="string">&quot;r&quot;</span>(smem_addr), <span class="string">&quot;r&quot;</span>(pred))</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-完整工作流程示例"><a href="#9-完整工作流程示例" class="headerlink" title="9. 完整工作流程示例"></a>9. 完整工作流程示例</h2><p>下图展示了 Producer 和 Consumer 之间的交互时序：</p>
<pre class="mermaid">sequenceDiagram
    participant P as Producer
    participant FB as FullBarrier
    participant EB as EmptyBarrier
    participant BUF as SMEM Buffer
    participant C as Consumer

    Note over P,C: Stage i 的一次完整迭代

    rect rgb(232, 245, 233)
        Note over P: Producer Phase
        P->>EB: wait(phase) - 等待空间
        EB-->>P: 空间已释放
        P->>FB: arrive_and_expect_tx(bytes)
        P->>BUF: TMA Load (异步)
        Note over FB: TMA完成后自动<br/>complete_tx
    end

    rect rgb(227, 242, 253)
        Note over C: Consumer Phase
        C->>FB: wait(phase) - 等待数据
        FB-->>C: 数据已就绪
        BUF->>C: 读取数据
        Note over C: MMA 计算
        C->>EB: arrive() - 释放空间
    end

    Note over P,C: Phase 翻转后进入下一轮</pre>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Producer 线程（TMA 加载器）</span></span><br><span class="line">PipelineState producer_state = <span class="built_in">make_producer_start_state</span>&lt;Pipeline&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; num_tiles; ++k) &#123;</span><br><span class="line">  <span class="comment">// 1. 获取缓冲区（等待空间 + 设置期望字节数）</span></span><br><span class="line">  pipeline.<span class="built_in">producer_acquire</span>(producer_state);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 获取 barrier 指针供 TMA 使用</span></span><br><span class="line">  <span class="keyword">auto</span>* barrier = pipeline.<span class="built_in">producer_get_barrier</span>(producer_state);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 发起 TMA 加载（硬件自动完成 barrier）</span></span><br><span class="line">  <span class="built_in">copy</span>(tma_load, gmem_tensor, smem_tensor, barrier);</span><br><span class="line"></span><br><span class="line">  ++producer_state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 退出前等待所有 Consumer 完成</span></span><br><span class="line">pipeline.<span class="built_in">producer_tail</span>(producer_state);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer 线程（MMA 计算）</span></span><br><span class="line">PipelineState consumer_state&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;  <span class="comment">// phase = 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; num_tiles; ++k) &#123;</span><br><span class="line">  <span class="comment">// 1. 尝试等待（非阻塞）</span></span><br><span class="line">  <span class="keyword">auto</span> token = pipeline.<span class="built_in">consumer_try_wait</span>(consumer_state);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 可以做一些其他工作...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 如果需要，阻塞等待</span></span><br><span class="line">  pipeline.<span class="built_in">consumer_wait</span>(consumer_state, token);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 使用 SMEM 数据进行 MMA 计算</span></span><br><span class="line">  <span class="built_in">gemm</span>(smem_tensor, accumulators);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 释放缓冲区给 Producer</span></span><br><span class="line">  pipeline.<span class="built_in">consumer_release</span>(consumer_state);</span><br><span class="line"></span><br><span class="line">  ++consumer_state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="10-关键要点总结"><a href="#10-关键要点总结" class="headerlink" title="10. 关键要点总结"></a>10. 关键要点总结</h2><ol>
<li><p><strong>SM90 专属</strong>：Pipeline 机制专为 NVIDIA Hopper 架构（SM90+）设计</p>
</li>
<li><p><strong>双 Barrier 架构</strong>：</p>
<ul>
<li><code>FullBarrier</code>（ClusterTransactionBarrier）：Producer → Consumer，数据就绪信号</li>
<li><code>EmptyBarrier</code>（ClusterBarrier）：Consumer → Producer，空间释放信号</li>
</ul>
</li>
<li><p><strong>硬件加速</strong>：TMA 完成时自动 signal barrier，无需软件干预</p>
</li>
<li><p><strong>Phase 机制</strong>：phase 位使 barrier 可跨迭代复用</p>
</li>
<li><p><strong>Cluster 支持</strong>：通过 <code>mapa</code> 指令实现跨 CTA 的 barrier 操作</p>
</li>
<li><p><strong>Leader 模式</strong>：只有 leader 线程执行 barrier 的 arrive&#x2F;expect_tx 操作，避免重复</p>
</li>
</ol>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/NVIDIA/cutlass">CUTLASS GitHub 仓库</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/NVIDIA/cutlass/blob/main/include/cutlass/pipeline/sm90_pipeline.hpp">sm90_pipeline.hpp</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/NVIDIA/cutlass/blob/main/include/cutlass/arch/barrier.h">barrier.h</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-mbarrier">NVIDIA PTX ISA - mbarrier</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#asynchronous-barrier">CUDA Programming Guide - Asynchronous Barrier</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>CUTLASS SM90 Pipeline 与 mbarrier 深度解析</p><p><a href="https://drxuqian.github.io/2024/12/23/pipeline-barrier-ptx-mapping/">https://drxuqian.github.io/2024/12/23/pipeline-barrier-ptx-mapping/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>DrXuQian</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-12-23</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-12-24</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/CUTLASS/">CUTLASS</a><a class="link-muted mr-2" rel="tag" href="/tags/Pipeline/">Pipeline</a><a class="link-muted mr-2" rel="tag" href="/tags/mbarrier/">mbarrier</a><a class="link-muted mr-2" rel="tag" href="/tags/PTX/">PTX</a><a class="link-muted mr-2" rel="tag" href="/tags/SM90/">SM90</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/12/24/tma-multicast-deep-dive/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">CUTLASS SM90 TMA Multicast 深度解析</span></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="DrXuQian"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">DrXuQian</p><p class="is-size-6 is-block">CUDA/GPU Enthusiast</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">9</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/DrXuQian" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="GitHub" href="https://github.com/DrXuQian"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CUTLASS/"><span class="level-start"><span class="level-item">CUTLASS</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-12-23T16:00:00.000Z">2024-12-24</time></p><p class="title"><a href="/2024/12/24/tma-descriptor-deep-dive/">CUTLASS SM90 TMA Descriptor 深度解析</a></p><p class="categories"><a href="/categories/CUTLASS/">CUTLASS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-12-23T16:00:00.000Z">2024-12-24</time></p><p class="title"><a href="/2024/12/24/tma-multicast-deep-dive/">CUTLASS SM90 TMA Multicast 深度解析</a></p><p class="categories"><a href="/categories/CUTLASS/">CUTLASS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-12-22T16:00:00.000Z">2024-12-23</time></p><p class="title"><a href="/2024/12/23/pipeline-barrier-ptx-mapping/">CUTLASS SM90 Pipeline 与 mbarrier 深度解析</a></p><p class="categories"><a href="/categories/CUTLASS/">CUTLASS</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/CUTLASS/"><span class="tag">CUTLASS</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SM90/"><span class="tag">SM90</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PTX/"><span class="tag">PTX</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TMA/"><span class="tag">TMA</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Pipeline/"><span class="tag">Pipeline</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mbarrier/"><span class="tag">mbarrier</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CuTe/"><span class="tag">CuTe</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Multicast/"><span class="tag">Multicast</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cluster/"><span class="tag">Cluster</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="CUTLASS 学习笔记" height="28"></a><p class="is-size-7"><span>&copy; 2025 DrXuQian</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p><p class="is-size-7">© 2024 DrXuQian</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/DrXuQian"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    if (typeof mermaid !== 'undefined') {
      mermaid.initialize({ startOnLoad: true, theme: 'default' });
    }
  });
  document.addEventListener('pjax:complete', function() {
    if (typeof mermaid !== 'undefined') {
      mermaid.init(undefined, '.mermaid');
    }
  });
</script>
<script src="/js/theme-toggle.js"></script>
</body></html>